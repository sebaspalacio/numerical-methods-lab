<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Numerical Methods Lab</title>
  <!-- Tailwind CDN -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Plotly CDN -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    :root{
      --ink:#0f172a;
      --blue:#1d4ed8;
      --ok:#16a34a;
      --warn:#f59e0b;
      --err:#dc2626;
      --muted:#64748b;
      --card:#ffffff;
      --bg:#f8fafc;
      --line:#e5e7eb;
    }
    html,body{height:100%;}
    body{background:var(--bg);color:var(--ink);}
    .card{background:var(--card);border:1px solid var(--line);border-radius:1rem;padding:1rem;}
    .btn{display:inline-flex;align-items:center;justify-content:center;padding:.6rem 1rem;border-radius:.75rem;font-weight:700}
    .btn-primary{background:var(--blue);color:#fff;}
    .btn-ghost{background:#e5edff;color:#1d4ed8;}
    .btn-soft{background:#f1f5f9;color:#0f172a;}
    .btn[disabled]{opacity:.5;cursor:not-allowed;}
    .tab-on{background:var(--blue);color:#fff;}
    .tab-off{background:#eef2ff;color:#1e40af;}
    .badge{display:inline-flex;align-items:center;gap:.5rem;padding:.25rem .6rem;border-radius:.6rem;font-weight:700;}
    .badge-ok{background:color-mix(in srgb,var(--ok) 15%, white);color:var(--ok);border:1px solid color-mix(in srgb,var(--ok) 35%, white);}
    .badge-warn{background:color-mix(in srgb,var(--warn) 18%, white);color:var(--warn);border:1px solid color-mix(in srgb,var(--warn) 40%, white);}
    .badge-err{background:color-mix(in srgb,var(--err) 18%, white);color:var(--err);border:1px solid color-mix(in srgb,var(--err) 40%, white);}
    .code{font-family:ui-monospace,SFMono-Regular,Menlo,Monaco,Consolas,"Liberation Mono","Courier New",monospace;}
    .w-ch{font-variant-numeric:tabular-nums;}
    .grid-2{display:grid;grid-template-columns:1fr 1fr;gap:1rem;}
    .grid-3{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:1rem;}
    @media (max-width:1024px){.grid-2,.grid-3{grid-template-columns:1fr;}}
    .table-sm td,.table-sm th{padding:.35rem .5rem;border-bottom:1px solid var(--line);}
  </style>
</head>
<body>
  <!-- Header -->
  <header class="mx-auto max-w-6xl px-4 py-6">
    <h1 class="text-3xl font-bold">Numerical Methods Lab</h1>
    <p class="text-slate-600">Course-aligned toolbox — Root Finding • Direct / Iterative Linear Systems • Interpolation</p>
  </header>

  <main class="mx-auto max-w-6xl px-4 pb-24">

    <!-- Workspaces -->
    <section class="card mb-4">
      <div class="flex flex-wrap gap-2">
        <button id="tabRoot" class="btn tab-on">Root Finding</button>
        <button id="tabDirect" class="btn tab-off">Direct Methods (Factorizations)</button>
        <button id="tabIter" class="btn tab-off">Iterative Methods</button>
        <button id="tabInterp" class="btn tab-off">Interpolation</button>
      </div>
      <p class="text-sm text-slate-600 mt-2">Select a workspace. The method list and inputs adapt automatically.</p>
    </section>

    <!-- Method selector -->
    <section class="card mb-6">
      <div class="grid-3">
        <div>
          <label class="block text-sm font-semibold mb-1">Method</label>
          <select id="method" class="w-full rounded-lg border p-2"></select>
        </div>
        <div>
          <label class="block text-sm font-semibold mb-1">Quick actions</label>
          <div class="flex gap-2">
            <button id="runBtn" class="btn btn-primary" type="button">Run</button>
            <button id="clearBtn" class="btn btn-ghost" type="button">Clear</button>
          </div>
        </div>
        <div class="flex items-end justify-end">
          <label class="text-sm flex items-center gap-2">
            <input id="ack" type="checkbox"/>
            <span>I checked grammar, numeric formats, and prerequisites.</span>
          </label>
        </div>
      </div>
      <div id="prereq" class="text-sm text-slate-700 mt-3"></div>
    </section>

    <!-- Inputs & Status/Chart -->
    <section class="grid-2">
      <div class="card">
        <h3 class="text-lg font-semibold mb-2">Inputs</h3>
        <div id="inputs"></div>
      </div>
      <div class="card">
        <h3 class="text-lg font-semibold mb-2">Status & Chart</h3>
        <div id="status" class="mb-2"></div>
        <div id="plot" style="width:100%;height:440px;"></div>
      </div>
    </section>

    <!-- Outputs -->
    <section class="card mt-6">
      <h3 class="text-lg font-semibold mb-2">Outputs</h3>
      <div id="outputs" class="space-y-3 text-sm code w-ch"></div>
    </section>

    <!-- Iterations table -->
    <section class="card mt-6">
      <h3 class="text-lg font-semibold mb-2">Iteration table</h3>
      <div id="iters"></div>
    </section>

    <!-- History -->
    <section class="card mt-6">
      <div class="flex items-center justify-between">
        <h3 class="text-lg font-semibold">History (recent runs)</h3>
        <button class="btn btn-ghost" type="button" id="clearHistory">Clear history</button>
      </div>
      <div id="history" class="mt-3"></div>
    </section>

    <!-- Quick guide -->
    <section class="card mt-6">
      <h3 class="text-lg font-semibold">Quick guide</h3>
      <div id="guide" class="mt-2 text-sm text-slate-700 space-y-2"></div>
    </section>

  </main>

  <script>
  /* ============================ Utilities ============================ */
  const fmt=(x,k=6)=>Number.isFinite(x)?Number(x).toFixed(k):String(x);
  const zeros=(n,m)=>Array.from({length:n},()=>Array(m).fill(0));
  const eye=n=>{const I=zeros(n,n);for(let i=0;i<n;i++)I[i][i]=1;return I;};
  const dot=(a,b)=>a.reduce((s,v,i)=>s+v*b[i],0);
  const matVec=(A,x)=>A.map(r=>dot(r,x));
  const vecSub=(a,b)=>a.map((v,i)=>v-b[i]);
  const norm2=v=>Math.sqrt(dot(v,v));
  const copy=A=>A.map(r=>r.slice());
  const transpose=A=>A[0].map((_,j)=>A.map(r=>r[j]));
  function fixedWidthMatrix(M,k=6){
    const s=M.map(r=>r.map(v=>fmt(v,k)));
    const w=Math.max(...s.flat().map(t=>t.length));
    return s.map(r=>' '+r.map(t=>t.padStart(w,' ')).join(' ')+' ').join('\\n');
  }
  class Recommendation extends Error{}

  function statusBadge(kind,msg){
    const cls=kind==='ok'?'badge-ok':kind==='warn'?'badge-warn':'badge-err';
    document.getElementById('status').innerHTML =
      '<div class="card"><span class="badge '+cls+'">'+kind.toUpperCase()+
      '</span> <span class="ml-2">'+msg+'</span></div>';
  }

  /* ============================ Parsers & validation ============================ */
  function parseNum(id,label=id){
    const el=document.getElementById(id); if(!el) throw Error('Missing input: '+label);
    const raw=el.value.trim().replace(/,/g,'');
    if(!/^[-]?(\\d+(\\.\\d*)?|\\.\\d+)(e[-+]?\\d+)?$/i.test(raw)) throw Error('Invalid number in '+label);
    return Number(raw);
  }
  function parseFun(id){
    const src=document.getElementById(id).value.trim();
    if(!/[xX]/.test(src)) throw Error('Function must contain variable x');
    if(!/^[\\d\\sxX\\w\\+\\-\\*\\/\\^\\.\\(\\),]*$/.test(src)) throw Error('Function contains invalid characters');
    const f=new Function('x','with(Math){return '+src.replaceAll('^','**')+'}');
    try{ void f(0); }catch(e){ throw Error('Function is not valid'); }
    return {src,f};
  }
  function parseVec(id,label=id){
    const raw=document.getElementById(id).value.trim(); if(!raw) throw Error(label+' is empty');
    const arr=raw.split(/[ ,\\t\\n]+/).filter(Boolean).map(Number);
    if(arr.some(v=>!Number.isFinite(v))) throw Error(label+' has invalid entries');
    return arr;
  }
  function parseMat(id,label=id){
    const raw=document.getElementById(id).value.trim(); if(!raw) throw Error(label+' is empty');
    const rows=raw.split(/\\n|;/).map(r=>r.trim()).filter(Boolean);
    const M=rows.map(r=>r.split(/[ ,\\t]+/).filter(Boolean).map(Number));
    const m=M[0].length;
    if(M.some(r=>r.length!==m)) throw Error(label+' must be rectangular');
    if(M.flat().some(v=>!Number.isFinite(v))) throw Error(label+' has invalid entries');
    return M;
  }
  function parsePairs(id){
    const raw=document.getElementById(id).value.trim(); if(!raw) throw Error('Table is empty');
    const X=[],Y=[];
    raw.split(/\\n+/).forEach(line=>{
      const parts=line.split(/[;\\s,]+/).filter(Boolean).map(Number);
      if(parts.length!==2 || parts.some(v=>!Number.isFinite(v))) throw Error('Each line must be x;y with numeric values');
      X.push(parts[0]); Y.push(parts[1]);
    });
    return {X,Y};
  }

  /* ============================ Linear algebra helpers ============================ */
  function fwdSub(L,b){
    const n=L.length,y=Array(n).fill(0);
    for(let i=0;i<n;i++){
      let s=0;for(let j=0;j<i;j++) s+=L[i][j]*y[j];
      if(Math.abs(L[i][i])<1e-14) throw Error('Zero on diagonal in forward substitution');
      y[i]=(b[i]-s)/L[i][i];
    } return y;
  }
  function bwdSub(U,y){
    const n=U.length,x=Array(n).fill(0);
    for(let i=n-1;i>=0;i--){
      let s=0;for(let j=i+1;j<n;j++) s+=U[i][j]*x[j];
      if(Math.abs(U[i][i])<1e-14) throw Error('Zero on diagonal in backward substitution');
      x[i]=(y[i]-s)/U[i][i];
    } return x;
  }
  function matMul(A,B){
    const n=A.length,m=B[0].length,k=B.length,C=zeros(n,m);
    for(let i=0;i<n;i++) for(let j=0;j<m;j++){
      let s=0; for(let t=0;t<k;t++) s+=A[i][t]*B[t][j]; C[i][j]=s;
    } return C;
  }
  function inv(M){
    const n=M.length,A=copy(M),I=eye(n);
    for(let i=0;i<n;i++){
      let piv=i,mv=Math.abs(A[i][i]);
      for(let r=i+1;r<n;r++) if(Math.abs(A[r][i])>mv){mv=Math.abs(A[r][i]);piv=r;}
      if(piv!==i){ [A[i],A[piv]]=[A[piv],A[i]]; [I[i],I[piv]]=[I[piv],I[i]]; }
      const d=A[i][i]; if(Math.abs(d)<1e-14) throw Error('Singular matrix');
      for(let j=0;j<n;j++){ A[i][j]/=d; I[i][j]/=d; }
      for(let r=0;r<n;r++) if(r!==i){
        const m=A[r][i];
        for(let j=0;j<n;j++){ A[r][j]-=m*A[i][j]; I[r][j]-=m*I[i][j]; }
      }
    } return I;
  }
  function spectralRadius(T,max=200){
    const n=T.length; let v=Array(n).fill(0).map((_,i)=>i===0?1:0), l=0;
    for(let k=0;k<max;k++){
      const w=matVec(T,v), nrm=norm2(w); if(nrm===0) return 0;
      v=w.map(z=>z/nrm); const Tv=matVec(T,v); l=dot(v,Tv);
    } return Math.abs(l);
  }

  /* ============================ Plot helpers ============================ */
  const Plots={
    blank(div,msg){
      Plotly.newPlot(div,[{x:[0],y:[0],mode:'markers',type:'scatter',marker:{opacity:0}}],{annotations:[{text:msg,showarrow:false}],margin:{t:20},showlegend:false});
    },
    func(div,f,range,marks){
      const [L,R]=range; const xs=[],ys=[]; const a=Math.min(L,R), b=Math.max(L,R); const n=240;
      for(let i=0;i<=n;i++){ const x=a+(b-a)*i/n; xs.push(x); ys.push(f(x)); }
      const data=[{x:xs,y:ys,mode:'lines',type:'scatter',name:'f(x)'}];
      if(marks && marks.length){
        data.push({x:marks,y:marks.map(_=>0),mode:'markers+text',text:marks.map(x=>fmt(x,4)),textposition:'top center',name:'iter'});
      }
      Plotly.newPlot(div,data,{margin:{t:20},showlegend:false});
    },
    series(div,arr,title){
      Plotly.newPlot(div,[{x:arr.map((_,i)=>i+1), y:arr, mode:'lines+markers+text', text:arr.map(v=>fmt(v,3)), textposition:'top center'}], {margin:{t:20}, xaxis:{title:'k'}, yaxis:{title:'||e||'}, title});
    },
    scatterFit(div,pts,poly,spl){
      const {X,Y}=pts;
      const data=[{x:X,y:Y,mode:'markers+text',type:'scatter',text:Y.map(v=>fmt(v,3)),textposition:'top center',name:'data'}];
      if(poly){
        const n=poly.length;
        const xs=[...Array(240).keys()].map(i=>X[0]+(X[X.length-1]-X[0])*i/239);
        const ys=xs.map(x=>poly.reduce((s,c,j)=> s + c*Math.pow(x, n-1-j), 0));
        data.push({x:xs,y:ys,mode:'lines',name:'fit'});
      }
      if(spl){
        for(let i=0;i<spl.length;i++){
          const a=X[i], b=X[i+1];
          const xs=[...Array(60).keys()].map(k=>a + (b-a)*k/59);
          let ys;
          if(spl[i].length===2){ const [p,q]=spl[i]; ys=xs.map(x=>p*x+q); }
          else if(spl[i].length===3){ const [A,B,C]=spl[i]; ys=xs.map(x=>A*x*x+B*x+C); }
          else { const [A,B,C,D]=spl[i]; ys=xs.map(x=>((A*x+B)*x+C)*x+D); }
          data.push({x:xs,y:ys,mode:'lines',line:{dash:'dot'},showlegend:false});
        }
      }
      Plotly.newPlot(div,data,{margin:{t:20}});
    }
  };

  /* ============================ Root methods (a>b) ============================ */
  function incSearch(f,a,delta,nmax,bRight){
    if(delta===0) return {bracket:null,msg:'Δ must be non-zero.'};
    let a0=a, b0=a - Math.abs(delta);
    if(typeof bRight==='number') b0=bRight;
    let y0=f(a0);
    for(let k=0;k<nmax;k++){
      const y1=f(b0);
      if(y0*y1<0) return { bracket:[a0,b0], msg:`Sign change in [${b0}, ${a0}]` };
      a0=b0; y0=y1; b0 = b0 - Math.abs(delta);
    }
    return { bracket:null, msg:'No sign change found on the scanned range.' };
  }
  function bisection(f,a,b,tol,maxIt){
    if(!(a>b)) throw Error('For this course variant we expect a > b');
    if(f(a)*f(b)>=0) throw Recommendation('No sign change on [b,a]. Choose an interval where f crosses the x-axis.');
    const iters=[]; let fa=f(a),fb=f(b),mid,fm;
    for(let k=1;k<=maxIt;k++){
      mid=(a+b)/2; fm=f(mid);
      iters.push([k,a,b,mid,fa,fb,fm,Math.abs(a-b)/2]);
      if(Math.abs(fm)<=tol || Math.abs(a-b)<=2*tol) break;
      if(fa*fm<0){ b=mid; fb=fm; } else { a=mid; fa=fm; }
    }
    return {root:mid,iters};
  }
  function falsePosition(f,a,b,tol,maxIt){
    if(!(a>b)) throw Error('We expect a>b');
    if(f(a)*f(b)>=0) throw Recommendation('No sign change on [b,a].');
    const iters=[]; let fa=f(a), fb=f(b), xm=a;
    for(let k=1;k<=maxIt;k++){
      const denom=fb-fa; if(Math.abs(denom)<1e-14) throw Recommendation('Denominator ~ 0; choose another interval.');
      xm = b - fb*(b-a)/denom; const fm=f(xm);
      iters.push([k,a,b,xm,fa,fb,fm,Math.abs(b-a)]);
      if(Math.abs(fm)<=tol) break;
      if(fa*fm<0){ b=xm; fb=fm; } else { a=xm; fa=fm; }
    }
    return {root:xm,iters};
  }
  function fixedPoint(g,[L,R],x0,tol,maxIt){
    const iters=[];
    for(let k=1;k<=maxIt;k++){
      const x1=g(x0); const err=Math.abs(x1-x0);
      iters.push([k,x0,x1,err]);
      if(err<=tol) return {root:x1,iters};
      if(!(x1>=L && x1<=R)) throw Recommendation('Iterate left the interval. Tighten [b,a] or reformulate g(x).');
      x0=x1;
    }
    return {root:x0,iters};
  }
  function newtonRoot(f,x0,tol,maxIt){
    const iters=[], der=x=>(f(x+1e-6)-f(x-1e-6))/(2e-6);
    let x=x0, fx=f(x);
    for(let k=1;k<=maxIt;k++){
      const d=der(x); if(Math.abs(d)<1e-14) throw Recommendation('Derivative near zero; try another x0');
      const x1=x - fx/d; iters.push([k,x,fx,d,x1,Math.abs(x1-x)]);
      if(Math.abs(x1-x)<=tol){ x=x1; fx=f(x); break; }
      x=x1; fx=f(x);
    }
    return {root:x,iters};
  }
  function secant(f,[L,R],x0,x1,tol,maxIt){
    const iters=[];
    for(let k=1;k<=maxIt;k++){
      const f0=f(x0), f1=f(x1), denom=f1-f0; if(Math.abs(denom)<1e-14) throw Recommendation('Denominator ~ 0; pick better seeds');
      const x2=x1 - f1*(x1-x0)/denom;
      if(!(x2>=L && x2<=R)) throw Recommendation('Iterate left the interval; tighten [b,a] or change seeds');
      const err=Math.abs(x2-x1); iters.push([k,x0,x1,x2,f(x2),err]);
      if(err<=tol) return {root:x2,iters};
      x0=x1; x1=x2;
    }
    return {root:x1,iters};
  }

  /* ============================ Direct (factorizations) ============================ */
  function luSimple(A){
    const n=A.length,L=eye(n),U=zeros(n,n),M=copy(A);
    for(let i=0;i<n-1;i++){
      for(let j=i+1;j<n;j++){
        if(M[j][i]!==0){ const m=M[j][i]/M[i][i]; L[j][i]=m; for(let k=i;k<n;k++) M[j][k]-=m*M[i][k]; }
      }
      for(let k=i;k<n;k++) U[i][k]=M[i][k];
    }
    U[n-1][n-1]=M[n-1][n-1]; return {L,U};
  }
  function luPartialPivot(A){
    const n=A.length,L=eye(n),U=zeros(n,n),P=eye(n),M=copy(A);
    for(let i=0;i<n-1;i++){
      let piv=i,mv=Math.abs(M[i][i]);
      for(let r=i+1;r<n;r++) if(Math.abs(M[r][i])>mv){mv=Math.abs(M[r][i]);piv=r;}
      if(piv!==i){ [M[i],M[piv]]=[M[piv],M[i]]; [P[i],P[piv]]=[P[piv],P[i]]; for(let k=0;k<i;k++) [L[i][k],L[piv][k]]=[L[piv][k],L[i][k]]; }
      for(let j=i+1;j<n;j++) if(M[j][i]!==0){ const m=M[j][i]/M[i][i]; L[j][i]=m; for(let k=i;k<n;k++) M[j][k]-=m*M[i][k]; }
      for(let k=i;k<n;k++) U[i][k]=M[i][k];
    }
    U[n-1][n-1]=M[n-1][n-1]; return {L,U,P};
  }
  function crout(A){
    const n=A.length,L=zeros(n,n),U=eye(n);
    for(let i=0;i<n;i++){
      for(let j=i;j<n;j++){ let s=0; for(let k=0;k<i;k++) s+=L[j][k]*U[k][i]; L[j][i]=A[j][i]-s; }
      for(let j=i+1;j<n;j++){ let s=0; for(let k=0;k<i;k++) s+=L[i][k]*U[k][j]; if(Math.abs(L[i][i])<1e-14) throw Error('Zero on diagonal in Crout'); U[i][j]=(A[i][j]-s)/L[i][i]; }
    } return {L,U};
  }
  function doolittle(A){
    const n=A.length,L=eye(n),U=zeros(n,n);
    for(let i=0;i<n;i++){
      for(let j=i;j<n;j++){ let s=0; for(let k=0;k<i;k++) s+=L[i][k]*U[k][j]; U[i][j]=A[i][j]-s; }
      for(let j=i+1;j<n;j++){ let s=0; for(let k=0;k<i;k++) s+=L[j][k]*U[k][i]; if(Math.abs(U[i][i])<1e-14) throw Error('Zero on diagonal in Doolittle'); L[j][i]=(A[j][i]-s)/U[i][i]; }
    } return {L,U};
  }
  function choleskyCourse(A){
    const n=A.length,L=zeros(n,n),U=zeros(n,n);
    if(Math.abs(A[0][0])<1e-14) throw Error('a_11 = 0; cannot start Cholesky.');
    for(let i=0;i<n;i++){
      let s=0; for(let k=0;k<i;k++) s+=L[i][k]*U[k][i];
      const diag=A[i][i]-s;
      if(diag<=0) throw Recommendation('Non-positive pivot in Cholesky (not SPD).');
      L[i][i]=Math.sqrt(diag); U[i][i]=L[i][i];
      for(let j=i+1;j<n;j++){
        let s2=0; for(let k=0;k<i;k++) s2+=L[j][k]*U[k][i];
        L[j][i]=(A[j][i]-s2)/U[i][i];
      }
      for(let j=i+1;j<n;j++){
        let s3=0; for(let k=0;k<i;k++) s3+=L[i][k]*U[k][j];
        U[i][j]=(A[i][j]-s3)/L[i][i];
      }
    } return {L,U};
  }

  /* ============================ Iterative methods ============================ */
  function jacobi(A,b,x0,tol,Nmax){
    const n=A.length; for(let i=0;i<n;i++) if(Math.abs(A[i][i])<1e-14) throw Error('Jacobi: zero on diagonal');
    const D=eye(n).map((r,i)=>r.map((_,j)=>i===j?A[i][i]:0));
    const L=zeros(n,n),U=zeros(n,n);
    for(let i=0;i<n;i++) for(let j=0;j<n;j++){ if(i>j) L[i][j]=-A[i][j]; else if(i<j) U[i][j]=-A[i][j]; }
    const Di=eye(n).map((r,i)=>r.map((_,j)=>i===j?1/D[i][i]:0));
    const S=zeros(n,n); for(let i=0;i<n;i++) for(let j=0;j<n;j++) S[i][j]=L[i][j]+U[i][j];
    const T=matMul(Di,S), C=matVec(Di,b), rho=spectralRadius(T);
    const iters=[]; let x=x0.slice(),E=Infinity,k=0;
    while(E>tol && k<Nmax){ const x1=matVec(T,x).map((v,i)=>v+C[i]); E=norm2(vecSub(x1,x)); iters.push([k+1,E,...x1]); x=x1; k++; }
    return {x,iters,T,C,rho};
  }
  function gaussSeidel(A,b,x0,tol,Nmax){
    const n=A.length; for(let i=0;i<n;i++) if(Math.abs(A[i][i])<1e-14) throw Error('Gauss-Seidel: zero on diagonal');
    const D=eye(n).map((r,i)=>r.map((_,j)=>i===j?A[i][i]:0));
    const L=zeros(n,n),U=zeros(n,n);
    for(let i=0;i<n;i++) for(let j=0;j<n;j++){ if(i>j) L[i][j]=-A[i][j]; else if(i<j) U[i][j]=-A[i][j]; }
    const DL=zeros(n,n); for(let i=0;i<n;i++) for(let j=0;j<n;j++) DL[i][j]=(i===j?D[i][i]:0)-L[i][j];
    const DLinv=inv(DL); const T=matMul(DLinv,U), C=matVec(DLinv,b), rho=spectralRadius(T);
    const iters=[]; let x=x0.slice(),E=Infinity,k=0;
    while(E>tol && k<Nmax){ const x1=matVec(T,x).map((v,i)=>v+C[i]); E=norm2(vecSub(x1,x)); iters.push([k+1,E,...x1]); x=x1; k++; }
    return {x,iters,T,C,rho};
  }
  function sor(A,b,x0,w,tol,Nmax){
    if(!(w>0 && w<2)) throw Recommendation('SOR requires 0<w<2');
    const n=A.length; for(let i=0;i<n;i++) if(Math.abs(A[i][i])<1e-14) throw Error('SOR: zero on diagonal');
    const D=eye(n).map((r,i)=>r.map((_,j)=>i===j?A[i][i]:0));
    const L=zeros(n,n),U=zeros(n,n);
    for(let i=0;i<n;i++) for(let j=0;j<n;j++){ if(i>j) L[i][j]=-A[i][j]; else if(i<j) U[i][j]=-A[i][j]; }
    const DL=zeros(n,n); for(let i=0;i<n;i++) for(let j=0;j<n;j++) DL[i][j]=(i===j?D[i][i]:0)-w*L[i][j];
    const DLinv=inv(DL); const S=zeros(n,n); for(let i=0;i<n;i++) for(let j=0;j<n;j++) S[i][j]=(1-w)*(i===j?D[i][i]:0)+w*U[i][j];
    const T=matMul(DLinv,S), C=matVec(DLinv,b).map(v=>w*v), rho=spectralRadius(T);
    const iters=[]; let x=x0.slice(),E=Infinity,k=0;
    while(E>tol && k<Nmax){ const x1=matVec(T,x).map((v,i)=>v+C[i]); E=norm2(vecSub(x1,x)); iters.push([k+1,E,...x1]); x=x1; k++; }
    return {x,iters,T,C,rho};
  }

  /* ============================ Interpolation ============================ */
  function solveRef(A,b){
    const n=A.length,M=copy(A),P=eye(n),L=eye(n);
    for(let i=0;i<n-1;i++){
      let piv=i,mv=Math.abs(M[i][i]);
      for(let r=i+1;r<n;r++) if(Math.abs(M[r][i])>mv){mv=Math.abs(M[r][i]);piv=r;}
      if(piv!==i){ [M[i],M[piv]]=[M[piv],M[i]]; [P[i],P[piv]]=[P[piv],P[i]]; for(let k=0;k<i;k++) [L[i][k],L[piv][k]]=[L[piv][k],L[i][k]]; }
      for(let j=i+1;j<n;j++){ const m=M[j][i]/M[i][i]; L[j][i]=m; for(let k=i;k<n;k++) M[j][k]-=m*M[i][k]; }
    }
    const y=fwdSub(L, matVec(P,b));
    return bwdSub(M,y);
  }
  function vandermondeCoef(X,Y){ const n=X.length,A=zeros(n,n); for(let i=0;i<n;i++) for(let j=0;j<n;j++) A[i][j]=Math.pow(X[i],n-1-j); return solveRef(A,Y); }
  function newtonDivDif(X,Y){
    const n=X.length,D=Array.from({length:n},()=>Array(n).fill(0));
    for(let i=0;i<n;i++) D[i][0]=Y[i];
    for(let j=1;j<n;j++) for(let i=j;i<n;i++){ const num=D[i][j-1]-D[i-1][j-1]; const den=X[i]-X[i-j]; D[i][j]=num/den; }
    const coef=Array(n).fill(0).map((_,i)=>D[i][i]); return {D,coef};
  }
  function polyMul(a,b){ const r=Array(a.length+b.length-1).fill(0); for(let i=0;i<a.length;i++) for(let j=0;j<b.length;j++) r[i+j]+=a[i]*b[j]; return r; }
  function scalePoly(p,s){ return p.map(c=>c*s); }
  function lagrangePolys(X,Y){
    const n=X.length; const L=Array(n).fill(0).map(()=>[1]);
    for(let i=0;i<n;i++){
      let poly=[1];
      for(let j=0;j<n;j++){
        if(i===j) continue;
        poly=polyMul(poly,[1,-X[j]]);
        const denom=X[i]-X[j];
        poly=poly.map(c=>c/denom);
      }
      L[i]=poly;
    }
    const deg = Math.max(...L.map(p=>p.length))-1;
    const Coef=Array(deg+1).fill(0);
    for(let i=0;i<n;i++){
      const p=scalePoly(L[i],Y[i]);
      for(let j=0;j<p.length;j++) Coef[Coef.length-p.length+j]+=p[j];
    }
    return {L,Coef};
  }
  function splineLineal(X,Y){
    const n=X.length, m=2*(n-1), A=zeros(m,m), b=Array(m).fill(0);
    let row=0;
    // S1(x0)=y0
    A[row][0]=X[0]; A[row][1]=1; b[row]=Y[0]; row++;
    // Si(xi)=yi for i=1..n-1
    for(let i=1;i<n;i++){ A[row][2*i-1]=X[i]; A[row][2*i]=1; b[row]=Y[i]; row++; }
    // Continuity at internal nodes: S_i(x_i)=S_{i+1}(x_i)
    for(let i=1;i<n-1;i++){
      A[row][2*i-1]=X[i]; A[row][2*i]=1;
      A[row][2*i+1]=-X[i]; A[row][2*i+2]=-1;
      b[row]=0; row++;
    }
    const c=solveRef(A,b);
    const S=[]; for(let i=0;i<n-1;i++) S.push([c[2*i],c[2*i+1]]);
    return S;
  }
  function splineCuadratico(X,Y){
    // Quadratic splines with C1 continuity and boundary a_0=0 (natural-like for quadratic)
    const n=X.length, m=3*(n-1), A=zeros(m,m), b=Array(m).fill(0);
    let row=0;
    // First interval has a0=0 → encode by setting directly
    // We'll solve unknowns in order [a0,b0,c0, a1,b1,c1, ...]
    // Encode S0(x0)=y0 and S0'(x0) = (y1-y0)/(x1-x0) as boundary for better behavior
    // Equations:
    // For each interval i: Si(xi)=yi and Si(x_{i+1})=y_{i+1}
    // For internal nodes: Si'(x_i)=S_{i-1}'(x_i)
    // Plus a0=0 and derivative at x0 as above to close the system.

    // a0 = 0
    A[row][0]=1; b[row]=0; row++;

    // S0(x0)=y0: a0 x0^2 + b0 x0 + c0 = y0
    A[row][0]=X[0]**2; A[row][1]=X[0]; A[row][2]=1; b[row]=Y[0]; row++;

    // S0'(x0) = slope forward
    const s0=(Y[1]-Y[0])/(X[1]-X[0]);
    A[row][0]=2*X[0]; A[row][1]=1; A[row][2]=0; b[row]=s0; row++;

    // For each interval i: Si(x_i)=y_i and Si(x_{i+1})=y_{i+1}
    for(let i=0;i<n-1;i++){
      const base=3*i;
      // Si(x_i)=y_i
      A[row][base]=X[i]**2; A[row][base+1]=X[i]; A[row][base+2]=1; b[row]=Y[i]; row++;
      // Si(x_{i+1})=y_{i+1}
      A[row][base]=X[i+1]**2; A[row][base+1]=X[i+1]; A[row][base+2]=1; b[row]=Y[i+1]; row++;
    }
    // C1 continuity for i=1..n-2: S_{i-1}'(x_i)=S_i'(x_i)
    for(let i=1;i<n-1;i++){
      const left=3*(i-1), right=3*i;
      A[row][left]   = 2*X[i]; A[row][left+1]   = 1; A[row][left+2]   = 0;
      A[row][right] += -2*X[i]; A[row][right+1] += -1; A[row][right+2] += 0;
      b[row]=0; row++;
    }

    // System is overdetermined by a bit with earlier three rows; we can trim duplicates
    // To keep consistency: build a reduced system picking first m rows
    const Ared=A.slice(0,m).map(r=>r.slice(0,m));
    const bred=b.slice(0,m);
    const c=solveRef(Ared,bred);
    const S=[]; for(let i=0;i<n-1;i++){ const a=c[3*i],d=c[3*i+1],e=c[3*i+2]; S.push([a,d,e]); }
    return S;
  }
  function splineCubico(X,Y){
    // Natural cubic splines (S''(x0)=S''(xn)=0)
    const n=X.length, h=[], alpha=Array(n).fill(0);
    for(let i=0;i<n-1;i++) h[i]=X[i+1]-X[i];
    for(let i=1;i<n-1;i++) alpha[i]=3*((Y[i+1]-Y[i])/h[i] - (Y[i]-Y[i-1])/h[i-1]);

    const l=Array(n).fill(0), mu=Array(n).fill(0), z=Array(n).fill(0);
    l[0]=1; mu[0]=0; z[0]=0;
    for(let i=1;i<n-1;i++){
      l[i]=2*(X[i+1]-X[i-1]) - h[i-1]*mu[i-1];
      mu[i]=h[i]/l[i];
      z[i]=(alpha[i]-h[i-1]*z[i-1])/l[i];
    }
    l[n-1]=1; z[n-1]=0;
    const c=Array(n).fill(0), bcoef=Array(n-1).fill(0), dcoef=Array(n-1).fill(0);
    for(let j=n-2;j>=0;j--){
      c[j]=z[j]-mu[j]*c[j+1];
      bcoef[j]=(Y[j+1]-Y[j])/h[j] - h[j]*(c[j+1]+2*c[j])/3;
      dcoef[j]=(c[j+1]-c[j])/(3*h[j]);
    }
    // Return piecewise coefficients for interval i: [a,b,c,d] with a*x^3+b*x^2+c*x+d
    const S=[];
    for(let i=0;i<n-1;i++){
      const a=dcoef[i], b=bcoef[i] - 2*c[i]*X[i] - 3*dcoef[i]*X[i]*X[i];
      // But it's easier to form polynomial in expanded form: S_i(x)=A x^3 + B x^2 + C x + D
      // Using Hermite-like form is verbose; build explicit coefficients by shifting:
      // S_i(x)=Y[i] + b_i (x-X[i]) + c_i (x-X[i])^2 + d_i (x-X[i])^3
      const A = dcoef[i];
      const B = c[i] - 3*dcoef[i]*X[i];
      const C = bcoef[i] - 2*c[i]*X[i] + 3*dcoef[i]*X[i]*X[i];
      const D = Y[i] - bcoef[i]*X[i] + c[i]*X[i]*X[i] - dcoef[i]*X[i]*X[i]*X[i];
      S.push([A,B,C,D]);
    }
    return S;
  }

  /* ============================ Workspaces & Methods ============================ */
  const METHODS_ROOT = {
    'Incremental Search': {
      id:'incremental',
      inputs:[
        {id:'fx',label:'f(x) =',type:'fun',hint:'x**3 - 7*x + 6'},
        {id:'a',label:'a (left, greater)',type:'num',def:'3'},
        {id:'b',label:'b (right, smaller)',type:'num',def:'0.5'},
        {id:'delta',label:'Δ (step)',type:'num',def:'0.5'},
        {id:'nmax',label:'Max steps',type:'num',def:'100'}
      ],
      prereq:'We follow the course convention a>b. This scans for sign changes to later apply bisection/false position.',
      run:()=>{
        const {src,f}=parseFun('fx');
        const a=parseNum('a'), b=parseNum('b'), delta=parseNum('delta'), nmax=parseNum('nmax');
        if(!(a>b)) throw Error('Incremental search expects a>b (left > right).');
        const {bracket,msg}=incSearch(f,a,delta,nmax,b);
        if(!bracket){ throw new Recommendation(msg+' Try a different Δ or move a.'); }
        return {status:['ok','Bracket found'], summary:`Use [${fmt(bracket[0])}, ${fmt(bracket[1])}]`, details:{fsrc:src, plot:(div)=>Plots.func(div,f,[bracket[1],bracket[0]],[bracket[0],bracket[1]])}};
      }
    },
    'Bisection (a>b)': {
      id:'bisection',
      inputs:[
        {id:'fx',label:'f(x) =',type:'fun',hint:'x**3 - 7*x + 6'},
        {id:'a',label:'a (left, greater)',type:'num',def:'3'},
        {id:'b',label:'b (right, smaller)',type:'num',def:'0.5'},
        {id:'tol',label:'tol',type:'num',def:'1e-6'},
        {id:'kmax',label:'max iterations',type:'num',def:'100'}
      ],
      prereq:'Requires a>b and sign change f(a)·f(b)<0.',
      run:()=>{
        const {src,f}=parseFun('fx'); const a=parseNum('a'), b=parseNum('b'), tol=parseNum('tol'), k=parseNum('kmax');
        const out=bisection(f,a,b,tol,k);
        return {status:['ok','Bisection completed'], summary:`root ≈ ${fmt(out.root)}`, details:{iters:out.iters, fsrc:src, plot:(div)=>Plots.func(div,f,[b,a],[out.root])}};
      }
    },
    'False Position (a>b)': {
      id:'falsePosition',
      inputs:[
        {id:'fx',label:'f(x) =',type:'fun',hint:'x**3 - 7*x + 6'},
        {id:'a',label:'a (left, greater)',type:'num',def:'3'},
        {id:'b',label:'b (right, smaller)',type:'num',def:'0.5'},
        {id:'tol',label:'tol',type:'num',def:'1e-6'},
        {id:'kmax',label:'max iterations',type:'num',def:'100'}
      ],
      prereq:'Requires a>b and sign change.',
      run:()=>{
        const {src,f}=parseFun('fx'); const a=parseNum('a'), b=parseNum('b'), tol=parseNum('tol'), k=parseNum('kmax');
        const out=falsePosition(f,a,b,tol,k);
        return {status:['ok','False Position completed'], summary:`root ≈ ${fmt(out.root)}`, details:{iters:out.iters, fsrc:src, plot:(div)=>Plots.func(div,f,[b,a],[out.root])}};
      }
    },
    'Fixed Point': {
      id:'fixedPoint',
      inputs:[
        {id:'fx',label:'f(x) =',type:'fun',hint:'x**3 - 7*x + 6'},
        {id:'gx',label:'g(x) =',type:'fun',hint:'(x + (7*x - 6)/3)/2'},
        {id:'a',label:'a (left, greater)',type:'num',def:'3'},
        {id:'b',label:'b (right, smaller)',type:'num',def:'0.5'},
        {id:'x0',label:'x0',type:'num',def:'1.5'},
        {id:'tol',label:'tol',type:'num',def:'1e-6'},
        {id:'kmax',label:'max iterations',type:'num',def:'100'}
      ],
      prereq:'Prefer a contractive g on [b,a] and g([b,a]) ⊆ [b,a].',
      run:()=>{
        const {src,f}=parseFun('fx'); const {f:gx}=parseFun('gx');
        const a=parseNum('a'), b=parseNum('b'), x0=parseNum('x0'), tol=parseNum('tol'), k=parseNum('kmax');
        const out=fixedPoint(gx,[b,a],x0,tol,k);
        return {status:['ok','Fixed Point completed'], summary:`root ≈ ${fmt(out.root)}`, details:{iters:out.iters, fsrc:src, plot:(div)=>Plots.func(div,f,[b,a],out.iters.map(r=>r[2]))}};
      }
    },
    'Newton (x0=0 default)': {
      id:'newton',
      inputs:[
        {id:'fx',label:'f(x) =',type:'fun',hint:'x**3 - 7*x + 6'},
        {id:'x0',label:'x0',type:'num',def:'0'},
        {id:'tol',label:'tol',type:'num',def:'1e-6'},
        {id:'kmax',label:'max iterations',type:'num',def:'50'}
      ],
      prereq:'Derivative must not be near 0 around the root.',
      run:()=>{
        const {src,f}=parseFun('fx'); const x0=parseNum('x0'), tol=parseNum('tol'), k=parseNum('kmax');
        const out=newtonRoot(f,x0,tol,k);
        return {status:['ok','Newton completed'], summary:`root ≈ ${fmt(out.root)}`, details:{iters:out.iters, fsrc:src, plot:(div)=>Plots.func(div,f,[x0-5,x0+5],out.iters.map(r=>r[4]))}};
      }
    },
    'Secant': {
      id:'secant',
      inputs:[
        {id:'fx',label:'f(x) =',type:'fun',hint:'x**3 - 7*x + 6'},
        {id:'a',label:'a (left, greater)',type:'num',def:'3'},
        {id:'b',label:'b (right, smaller)',type:'num',def:'0.5'},
        {id:'x0',label:'x0',type:'num',def:'1.0'},
        {id:'x1',label:'x1',type:'num',def:'2.0'},
        {id:'tol',label:'tol',type:'num',def:'1e-6'},
        {id:'kmax',label:'max iterations',type:'num',def:'100'}
      ],
      prereq:'Denominator f(x1)-f(x0) must not be ~0.',
      run:()=>{
        const {src,f}=parseFun('fx'); const a=parseNum('a'), b=parseNum('b'), x0=parseNum('x0'), x1=parseNum('x1'), tol=parseNum('tol'), k=parseNum('kmax');
        const out=secant(f,[b,a],x0,x1,tol,k);
        return {status:['ok','Secant completed'], summary:`root ≈ ${fmt(out.root)}`, details:{iters:out.iters, fsrc:src, plot:(div)=>Plots.func(div,f,[b,a],out.iters.map(r=>r[3]))}};
      }
    }
  };

  const METHODS_DIRECT = {
    'LU (simple)': {
      id:'luSimple',
      inputs:[{id:'A',label:'A (rows by newline; cols by space/comma)',type:'mat'},{id:'b',label:'b (vector)',type:'vec'}],
      prereq:'Square invertible A.',
      run:()=>{
        const A=parseMat('A'), b=parseVec('b'); if(A.length!==A[0].length) throw Error('A must be square');
        const {L,U}=luSimple(A); const x=bwdSub(U,fwdSub(L,b));
        return {status:['ok','LU (simple) completed'], summary:`x = [${x.map(v=>fmt(v)).join(', ')}]`, details:{matrices:{L,U}}};
      }
    },
    'LU (partial pivot)': {
      id:'luPP',
      inputs:[{id:'A',label:'A',type:'mat'},{id:'b',label:'b',type:'vec'}],
      prereq:'Square invertible A. Shows L,U,P.',
      run:()=>{
        const A=parseMat('A'), b=parseVec('b'); if(A.length!==A[0].length) throw Error('A must be square');
        const {L,U,P}=luPartialPivot(A); const x=bwdSub(U,fwdSub(L, matVec(P,b)));
        return {status:['ok','LU (partial pivot) completed'], summary:`x = [${x.map(v=>fmt(v)).join(', ')}]`, details:{matrices:{L,U,P}}};
      }
    },
    'Crout': {
      id:'crout',
      inputs:[{id:'A',label:'A',type:'mat'},{id:'b',label:'b',type:'vec'}],
      prereq:'L non-unit diag; U unit diag.',
      run:()=>{
        const A=parseMat('A'), b=parseVec('b'); const {L,U}=crout(A); const x=bwdSub(U, fwdSub(L,b));
        return {status:['ok','Crout completed'], summary:`x = [${x.map(v=>fmt(v)).join(', ')}]`, details:{matrices:{L,U}}};
      }
    },
    'Doolittle': {
      id:'doolittle',
      inputs:[{id:'A',label:'A',type:'mat'},{id:'b',label:'b',type:'vec'}],
      prereq:'L unit diag; U general.',
      run:()=>{
        const A=parseMat('A'), b=parseVec('b'); const {L,U}=doolittle(A); const x=bwdSub(U, fwdSub(L,b));
        return {status:['ok','Doolittle completed'], summary:`x = [${x.map(v=>fmt(v)).join(', ')}]`, details:{matrices:{L,U}}};
      }
    },
    'Cholesky (course)': {
      id:'choleskyCourse',
      inputs:[{id:'A',label:'A (symmetric; SPD expected)',type:'mat'},{id:'b',label:'b',type:'vec'}],
      prereq:'Stops if a_11=0 or non-positive pivot appears.',
      run:()=>{
        const A=parseMat('A'), b=parseVec('b'); const {L,U}=choleskyCourse(A); const x=bwdSub(U, fwdSub(L,b));
        return {status:['ok','Cholesky completed'], summary:`x = [${x.map(v=>fmt(v)).join(', ')}]`, details:{matrices:{L,U}}};
      }
    }
  };

  const METHODS_ITER = {
    'Jacobi': {
      id:'jacobi',
      inputs:[
        {id:'A',label:'A',type:'mat'},
        {id:'b',label:'b',type:'vec'},
        {id:'x0',label:'x0',type:'vec',def:'0 0 0 0'},
        {id:'tol',label:'tol',type:'num',def:'1e-7'},
        {id:'N',label:'Nmax',type:'num',def:'100'}
      ],
      prereq:'Diagonal must have no zeros. We compute ρ(T).',
      run:()=>{
        const A=parseMat('A'), b=parseVec('b'), x0=parseVec('x0'), tol=parseNum('tol'), N=parseNum('N');
        const out=jacobi(A,b,x0,tol,N);
        const note = out.rho>1 ? ['warn',`Jacobi ρ(T)=${fmt(out.rho,6)} > 1 (may diverge).`] : ['ok',`Jacobi ρ(T)=${fmt(out.rho,6)}`];
        return {status:note, summary:`x ≈ [${out.x.map(v=>fmt(v)).join(', ')}]`, details:{iters:out.iters, matrices:{T:out.T,C:out.C}, series:out.iters.map(r=>r[1])}};
      }
    },
    'Gauss-Seidel': {
      id:'gs',
      inputs:[
        {id:'A',label:'A',type:'mat'},
        {id:'b',label:'b',type:'vec'},
        {id:'x0',label:'x0',type:'vec',def:'0 0 0 0'},
        {id:'tol',label:'tol',type:'num',def:'1e-7'},
        {id:'N',label:'Nmax',type:'num',def:'100'}
      ],
      prereq:'Diagonal without zeros. Shows ρ(T).',
      run:()=>{
        const A=parseMat('A'), b=parseVec('b'), x0=parseVec('x0'), tol=parseNum('tol'), N=parseNum('N');
        const out=gaussSeidel(A,b,x0,tol,N);
        return {status:['ok',`Gauss-Seidel ρ(T)=${fmt(out.rho,6)}`], summary:`x ≈ [${out.x.map(v=>fmt(v)).join(', ')}]`, details:{iters:out.iters, matrices:{T:out.T,C:out.C}, series:out.iters.map(r=>r[1])}};
      }
    },
    'SOR (w)': {
      id:'sor',
      inputs:[
        {id:'A',label:'A',type:'mat'},
        {id:'b',label:'b',type:'vec'},
        {id:'x0',label:'x0',type:'vec',def:'0 0 0 0'},
        {id:'w',label:'w (0<w<2)',type:'num',def:'1.5'},
        {id:'tol',label:'tol',type:'num',def:'1e-7'},
        {id:'N',label:'Nmax',type:'num',def:'100'}
      ],
      prereq:'Pick 0<w<2. Shows ρ(T).',
      run:()=>{
        const A=parseMat('A'), b=parseVec('b'), x0=parseVec('x0'), w=parseNum('w'), tol=parseNum('tol'), N=parseNum('N');
        const out=sor(A,b,x0,w,tol,N);
        return {status:['ok',`SOR ρ(T)=${fmt(out.rho,6)}`], summary:`x ≈ [${out.x.map(v=>fmt(v)).join(', ')}]`, details:{iters:out.iters, matrices:{T:out.T,C:out.C}, series:out.iters.map(r=>r[1])}};
      }
    }
  };

  const METHODS_INTERP = {
    'Vandermonde': {
      id:'vandermonde',
      inputs:[{id:'xy',label:'Table x;y per line (e.g., -1;15.5)', type:'pairs'}],
      prereq:'Builds Vandermonde and solves for coefficients.',
      run:()=>{ const {X,Y}=parsePairs('xy'); const coef=vandermondeCoef(X,Y); return {status:['ok','Vandermonde completed'], summary:`coef = [${coef.map(c=>fmt(c)).join(', ')}]`, details:{poly:coef, pts:{X,Y}}}; }
    },
    'Newton (divided differences)': {
      id:'newtonDD',
      inputs:[{id:'xy',label:'Table x;y per line', type:'pairs'}],
      prereq:'Shows divided-difference table and coefficients.',
      run:()=>{ const {X,Y}=parsePairs('xy'); const {D,coef}=newtonDivDif(X,Y); return {status:['ok','Newton (divided differences) completed'], summary:`b = [${coef.map(c=>fmt(c)).join(', ')}]`, details:{D, pts:{X,Y}}}; }
    },
    'Lagrange': {
      id:'lagrange',
      inputs:[{id:'xy',label:'Table x;y per line', type:'pairs'}],
      prereq:'Prints L_i(x) polynomials and final P(x).',
      run:()=>{ const {X,Y}=parsePairs('xy'); const {L,Coef}=lagrangePolys(X,Y); return {status:['ok','Lagrange completed'], summary:`P(x) coefficients = [${Coef.map(c=>fmt(c)).join(', ')}]`, details:{L, pts:{X,Y}, poly:Coef}}; }
    },
    'Linear splines': {
      id:'splLin',
      inputs:[{id:'xy',label:'Table x;y per line (x increasing)', type:'pairs'}],
      prereq:'Piecewise linear.',
      run:()=>{ const {X,Y}=parsePairs('xy'); const C=splineLineal(X,Y); return {status:['ok','Linear splines ready'], summary:`${C.length} segments`, details:{spl:C, pts:{X,Y}}}; }
    },
    'Quadratic splines': {
      id:'splQuad',
      inputs:[{id:'xy',label:'Table x;y per line', type:'pairs'}],
      prereq:'C1 continuity with boundary condition.',
      run:()=>{ const {X,Y}=parsePairs('xy'); const C=splineCuadratico(X,Y); return {status:['ok','Quadratic splines ready'], summary:`${C.length} segments`, details:{spl:C, pts:{X,Y}}}; }
    },
    'Cubic splines (natural)': {
      id:'splCub',
      inputs:[{id:'xy',label:'Table x;y per line', type:'pairs'}],
      prereq:'Natural boundary S""(x0)=S""(xn)=0.',
      run:()=>{ const {X,Y}=parsePairs('xy'); const C=splineCubico(X,Y); return {status:['ok','Cubic splines ready'], summary:`${C.length} segments`, details:{spl:C, pts:{X,Y}}}; }
    }
  };

  const METHODS_BY_WS = {
    root:   METHODS_ROOT,
    direct: METHODS_DIRECT,
    iter:   METHODS_ITER,
    interp: METHODS_INTERP
  };

  /* ============================ UI wiring ============================ */
  const els={
    tabRoot:document.getElementById('tabRoot'),
    tabDirect:document.getElementById('tabDirect'),
    tabIter:document.getElementById('tabIter'),
    tabInterp:document.getElementById('tabInterp'),
    method:document.getElementById('method'),
    runBtn:document.getElementById('runBtn'),
    clearBtn:document.getElementById('clearBtn'),
    prereq:document.getElementById('prereq'),
    inputs:document.getElementById('inputs'),
    status:document.getElementById('status'),
    plot:document.getElementById('plot'),
    outputs:document.getElementById('outputs'),
    iters:document.getElementById('iters'),
    history:document.getElementById('history'),
    clearHistory:document.getElementById('clearHistory'),
    guide:document.getElementById('guide'),
    ack:document.getElementById('ack')
  };

  let WS='root';

  function wireTabs(){
    els.tabRoot.addEventListener('click', ()=> setTab('root'));
    els.tabDirect.addEventListener('click', ()=> setTab('direct'));
    els.tabIter.addEventListener('click', ()=> setTab('iter'));
    els.tabInterp.addEventListener('click', ()=> setTab('interp'));
  }
  function setTab(active){
    WS=active;
    els.tabRoot.className   = 'btn ' + (WS==='root'   ? 'tab-on':'tab-off');
    els.tabDirect.className = 'btn ' + (WS==='direct' ? 'tab-on':'tab-off');
    els.tabIter.className   = 'btn ' + (WS==='iter'   ? 'tab-on':'tab-off');
    els.tabInterp.className = 'btn ' + (WS==='interp' ? 'tab-on':'tab-off');
    populateMethods();
    clearPanels();
    renderGuide();
  }
  function populateMethods(){
    const sel=els.method; sel.innerHTML='';
    const dict = METHODS_BY_WS[WS];
    Object.keys(dict).forEach(name=>{
      const o=document.createElement('option');
      o.value=dict[name].id; o.textContent=name; sel.appendChild(o);
    });
    renderInputs();
  }
  function renderInputs(){
    const dict = METHODS_BY_WS[WS];
    const id   = els.method.value || Object.values(dict)[0].id;
    const meta = Object.values(dict).find(m=>m.id===id) || Object.values(dict)[0];
    els.method.value = meta.id;
    els.prereq.textContent = meta.prereq || '';
    const box=els.inputs; box.innerHTML='';
    (meta.inputs||[]).forEach(inp=>{
      const w=document.createElement('div'); w.className='flex flex-col mb-3';
      const lab=document.createElement('label'); lab.className='text-sm font-semibold mb-1'; lab.textContent=inp.label; w.appendChild(lab);
      let el;
      if(inp.type==='fun'){ el=document.createElement('input'); el.placeholder=inp.hint||''; el.value=inp.def||''; }
      else if(inp.type==='num'){ el=document.createElement('input'); el.value=inp.def||''; }
      else if(inp.type==='vec'){ el=document.createElement('textarea'); el.rows=2; el.placeholder='e.g., 1 1 1'; el.value=inp.def||''; }
      else if(inp.type==='mat'){ el=document.createElement('textarea'); el.rows=4; el.placeholder='e.g., 4 -1 0 3\\n1 15.5 3 8\\n0 -1.3 -4 1.1\\n14 5 -2 30'; }
      else if(inp.type==='pairs'){ el=document.createElement('textarea'); el.rows=4; el.placeholder='x;y per line (e.g., -1;15.5)'; }
      el.id=inp.id; el.className='rounded-lg border p-2 code';
      w.appendChild(el); box.appendChild(w);
    });
  }
  function clearPanels(){ els.status.innerHTML=''; els.outputs.innerHTML=''; els.iters.innerHTML=''; els.plot.innerHTML=''; }

  function renderGuide(){
    const id = els.method.value;
    const guideMap = {
      incremental:[ 'Input: f(x), a>b, Δ, max steps.','Goal: bracket with sign change.','Then use Bisection/False Position.' ],
      bisection:[ 'Input: f(x), a>b, sign change.','Stop when |a-b|/2 ≤ tol or |Δx| ≤ tol.' ],
      falsePosition:[ 'Input: f(x), a>b, sign change.','May be slower if an endpoint sticks.' ],
      fixedPoint:[ 'Input: f(x), g(x), a>b, x0.','Aim for contractive g and invariant interval.' ],
      newton:[ 'Input: f(x), x0 (default 0).','Avoid |f’(x)| ≈ 0 near root.' ],
      secant:[ 'Input: f(x), a>b, x0, x1.','Denominator must not be ≈ 0.' ],
      luSimple:[ 'Input: A square, b.','Solve Ly=b then Ux=y.' ],
      luPP:[ 'Input: A square, b.','Partial pivoting adds robustness.' ],
      crout:[ 'Input: A square, b.','L non-unit diag; U unit diag.' ],
      doolittle:[ 'Input: A square, b.','L unit diag; U general.' ],
      choleskyCourse:[ 'Input: symmetric A, b.','Stops if a_11=0 or non-positive pivot.' ],
      jacobi:[ 'Input: A,b,x0,tol,N.','Diagonal must have no zeros; shows ρ(T).' ],
      gs:[ 'Input: A,b,x0,tol,N.','Gauss-Seidel; shows ρ(T).' ],
      sor:[ 'Input: A,b,x0,w,tol,N.','0<w<2; shows ρ(T).' ],
      vandermonde:[ 'Input: table x;y per line.','Builds Vandermonde and solves.' ],
      newtonDD:[ 'Input: table x;y per line.','Divided-difference table.' ],
      lagrange:[ 'Input: table x;y per line.','Builds L_i and final P(x).' ],
      splLin:[ 'Input: x;y per line (x increasing).','Piecewise linear.' ],
      splQuad:[ 'Input: x;y per line.','Quadratic, C1 continuity.' ],
      splCub:[ 'Input: x;y per line.','Natural cubic splines.' ],
    };
    const lines = guideMap[id] || [];
    els.guide.innerHTML = lines.map(s=>'<div>• '+s+'</div>').join('');
  }

  /* ============================ Runner ============================ */
  document.getElementById('runBtn').addEventListener('click', run);
  document.getElementById('clearBtn').addEventListener('click', ()=>{ clearPanels(); });

  function run(){
    try{
      if(!els.ack.checked) throw Error('Please tick the acknowledgment checkbox.');
      const dict = METHODS_BY_WS[WS];
      const id   = els.method.value;
      const meta = Object.values(dict).find(m=>m.id===id);
      if(!meta) throw Error('Unknown method');
      const res = meta.run();

      const kind = res.status?.[0] || 'ok';
      statusBadge(kind, res.status?.[1] || 'Done');

      // Outputs
      const out=document.getElementById('outputs'); out.innerHTML='';
      if(res.details?.matrices){
        const mats=res.details.matrices;
        for(const k in mats){
          out.innerHTML += '<div><div class="font-semibold">'+k+':</div><pre class="code">'+fixedWidthMatrix(mats[k])+'</pre></div>';
        }
      }
      if(res.details?.fsrc){ out.innerHTML += '<div><span class="font-semibold">f(x):</span> <span class="code">'+res.details.fsrc+'</span></div>'; }
      out.innerHTML += '<div><span class="font-semibold">Summary:</span> '+res.summary+'</div>';

      // Iterations (first 3 + last 3)
      const it=document.getElementById('iters'); it.innerHTML='';
      if(res.details?.iters?.length){
        const rows=res.details.iters;
        const head = '<tr class="text-left">'+rows[0].map((_,i)=>'<th class="table-sm">c'+(i+1)+'</th>').join('')+'</tr>';
        const rowHtml=a=>a.map(r=>'<tr>'+r.map(v=>'<td class="table-sm">'+(typeof v==='number'?fmt(v):v)+'</td>').join('')+'</tr>').join('');
        const first=rows.slice(0,3), last=rows.slice(-3);
        const mid=rows.length>6?'<tr><td class="table-sm text-center text-slate-400" colspan="'+rows[0].length+'">…</td></tr>':'';
        it.innerHTML='<table class="w-full table-sm">'+head+rowHtml(first)+mid+(rows.length>3?rowHtml(last):'')+'</table>';
      }

      // Plot
      const p=document.getElementById('plot'); p.innerHTML='';
      if(typeof res.details?.plot==='function'){ res.details.plot('plot'); }
      else if(WS==='iter' && res.details?.series){ Plots.series('plot', res.details.series, 'Residual norm per iteration'); }
      else if(WS==='interp' && res.details?.pts){ Plots.scatterFit('plot', res.details.pts, res.details.poly || null, res.details.spl || null); }
      else { Plots.blank('plot','See outputs at left.'); }

      // History
      History.add({time:Date.now(), ws:WS, method:id, fun:res.details?.fsrc||null, summary:res.summary});
      History.render();
      renderGuide();

    }catch(e){
      if(e instanceof Recommendation) statusBadge('warn', e.message);
      else statusBadge('err', e.message);
    }
  }

  /* ============================ History ============================ */
  const History={
    key:'nmh.history.v3',
    add(item){ const arr=this.get(); arr.unshift(item); localStorage.setItem(this.key, JSON.stringify(arr.slice(0,30))); },
    get(){ try{ return JSON.parse(localStorage.getItem(this.key)||'[]'); }catch{return [];} },
    clear(){ localStorage.removeItem(this.key); this.render(); },
    render(){
      const arr=this.get();
      document.getElementById('history').innerHTML = arr.length? arr.map(h=>{
        const when = new Date(h.time).toLocaleString();
        return `
          <div class="flex items-center justify-between border-b py-2">
            <div>
              <div class="font-semibold">${when}</div>
              <div class="text-sm">${h.ws} • ${h.method}${h.fun? ' • f(x)='+h.fun:''}</div>
              <div class="text-sm text-slate-600">${h.summary}</div>
            </div>
          </div>
        `;
      }).join('') : '<div class="text-sm text-slate-600">No runs yet.</div>';
    }
  };
  document.getElementById('clearHistory').addEventListener('click', ()=>History.clear());

  /* ============================ Boot ============================ */
  function init(){ wireTabs(); setTab('root'); History.render(); }
  if(document.readyState==='loading'){ document.addEventListener('DOMContentLoaded', init); } else { init(); }
  </script>
</body>
</html>
