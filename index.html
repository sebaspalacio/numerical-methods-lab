<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Numerical Lab ‚Äî Root Finding & Gaussian Elimination</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>
  <!-- Plotly -->
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    /* ===== Adventure Time‚Äìish Theme ===== */
    :root{
      --c-bg: #fcfbff;
      --c-card: #ffffff;
      --c-ink: #18212f;
      --c-soft: #6b7280;
      --c-primary: #7c3aed; /* grape */
      --c-primary-2: #22d3ee; /* cyan candy */
      --c-accent: #f472b6; /* bubblegum */
      --c-lime: #a3e635;
      --rad: 20px;
    }
    body{ background: radial-gradient(1200px 700px at 10% -20%, #fef6ff, transparent),
                       radial-gradient(800px 600px at 110% 10%, #ecfeff, transparent),
                       var(--c-bg); color: var(--c-ink); }
    .title{ font-weight: 900; letter-spacing: .2px; }
    .card{ background: var(--c-card); border-radius: var(--rad); box-shadow: 0 20px 40px rgba(24,33,47,.05); padding: 1.25rem; }
    .btn{ border-radius: 14px; padding:.6rem 1rem; font-weight:600; }
    .btn-primary{ background: linear-gradient(90deg,var(--c-primary),var(--c-primary-2)); color:#fff; }
    .btn-primary:hover{ filter: brightness(1.03); }
    .btn-soft{ background:#f3f4f6; color:#111827; }
    .btn-soft:hover{ background:#e5e7eb; }
    .badge{ display:inline-block; padding:.2rem .6rem; border-radius:999px; font-size:.75rem; font-weight:700;}
    .ok{ background:#ecfeff; color:#0e7490;}
    .warn{ background:#fff7ed; color:#b45309;}
    .err{ background:#fee2e2; color:#991b1b;}
    .input, .select, textarea{ width:100%; border:1px solid #e5e7eb; border-radius:14px; padding:.55rem .8rem; outline:none;}
    .input:focus, .select:focus, textarea:focus{ box-shadow:0 0 0 3px rgba(124,58,237,.15); border-color:#ddd6fe;}
    .hint{ color:#6b7280; font-size:.9rem;}
    .table{ width:100%; border-collapse: collapse; }
    .table th, .table td{ border-bottom:1px solid #eef2f7; padding:.55rem; text-align:right; font-variant-numeric: tabular-nums; }
    .table th{ color:#374151; text-align:center; }
    .pill{ padding:.18rem .5rem; border-radius:999px; background:#f3f4f6; font-weight:700; font-size:.75rem; }
    .soft-hr{ height:1px; background:linear-gradient(90deg,transparent,#e5e7eb,transparent); }
    .bubbly{ background: conic-gradient(from 180deg at 50% 50%, #fff 0deg, #fff 260deg, #f1f5f9 360deg); }
    .grid-2{ display:grid; grid-template-columns: 1fr 1fr; gap: 1rem; }
    @media (max-width: 1024px){ .grid-2{ grid-template-columns:1fr; } }
    .matrix-grid input{ width:90px; text-align:right; }
    .matrix-grid .cell{ padding:.15rem; }
    .code{ font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; background:#f8fafc; padding:.15rem .35rem; border-radius:8px; font-size:.85rem;}
  </style>
</head>
<body class="min-h-screen">
  <div class="max-w-7xl mx-auto p-4 lg:p-8">
    <!-- Hero -->
    <header class="mb-6">
      <div class="flex items-center gap-3">
        <div class="w-10 h-10 rounded-2xl bubbly grid place-items-center text-xl">üßÅ</div>
        <h1 class="title text-3xl">Numerical Methods Lab</h1>
      </div>
      <p class="hint mt-2">Choose a method, enter your data, and let the app guide you. If something can‚Äôt be applied, you‚Äôll get gentle tips to fix it, like a friendly Finn & Jake side-quest üó∫Ô∏è.</p>
    </header>

    <!-- Mode + Method -->
    <div class="card mb-6">
      <div class="grid lg:grid-cols-3 gap-4 items-end">
        <div>
          <label class="block text-sm font-semibold mb-1">Workspace</label>
          <div class="flex gap-2">
            <button id="tabRoot" class="btn btn-primary" aria-pressed="true">Root Finding</button>
            <button id="tabLinear" class="btn btn-soft" aria-pressed="false">Linear Systems</button>
          </div>
          <p class="hint mt-2">Toggle between <span class="code">f(x)=0</span> solvers and Gaussian elimination.</p>
        </div>
        <div>
          <label class="block text-sm font-semibold mb-1">Method</label>
          <select id="methodSelect" class="select">
            <optgroup label="Root Finding">
              <option value="incremental">Incremental Search</option>
              <option value="bisection">Bisection</option>
              <option value="falsePosition">False Position (Regula Falsi)</option>
              <option value="fixedPoint">Fixed Point</option>
              <option value="newton">Newton‚ÄìRaphson</option>
              <option value="secant">Secant</option>
              <option value="multiple">Modified Newton (Multiple Roots)</option>
            </optgroup>
            <optgroup label="Linear Systems (Gaussian)">
              <option value="gaussNone">No Pivoting</option>
              <option value="gaussPartial">Partial Pivoting</option>
              <option value="gaussTotal">Total Pivoting</option>
            </optgroup>
          </select>
        </div>
        <div class="flex gap-2">
          <button id="runBtn" class="btn btn-primary w-full">Run</button>
          <button id="resetBtn" class="btn btn-soft w-full">Reset</button>
        </div>
      </div>
    </div>

    <!-- ROOT PANEL -->
    <section id="rootPanel" class="card mb-6">
      <div class="grid-2">
        <div>
          <h2 class="text-lg font-semibold mb-3">Inputs ‚Äî Root Finding</h2>

          <label class="block text-sm font-semibold mb-1">f(x)</label>
          <input id="fxInput" class="input" value="x**3 - 7*x + 6" placeholder="Example: x**3 - 7*x + 6" />
          <p class="hint mb-3">You can use <span class="code">sin</span>, <span class="code">cos</span>, <span class="code">exp</span>, <span class="code">log</span>, <span class="code">sqrt</span>. <em>x^2</em> auto-converts to <em>x**2</em>.</p>

          <div id="gxGroup" class="hidden">
            <label class="block text-sm font-semibold mb-1">g(x) (for Fixed Point)</label>
            <input id="gxInput" class="input" value="(x + (7*x - 6)/3)/2" placeholder="Contractive mapping preferred" />
            <p class="hint mb-3">Tip: aim for max |g'(x)| &lt; 1 on your interval.</p>
          </div>

          <div class="grid grid-cols-2 gap-3">
            <div>
              <label class="block text-sm font-semibold mb-1">Interval a</label>
              <input id="aInput" type="number" class="input" value="0.5"/>
            </div>
            <div>
              <label class="block text-sm font-semibold mb-1">Interval b</label>
              <input id="bInput" type="number" class="input" value="3.0"/>
            </div>
          </div>

          <div id="deltaGroup" class="grid grid-cols-2 gap-3 mt-3 hidden">
            <div>
              <label class="block text-sm font-semibold mb-1">Delta</label>
              <input id="deltaInput" type="number" class="input" value="0.5" step="0.1"/>
            </div>
            <div>
              <label class="block text-sm font-semibold mb-1">Max steps</label>
              <input id="nmaxInput" type="number" class="input" value="100"/>
            </div>
          </div>

          <div id="x0x1Group" class="grid grid-cols-2 gap-3 mt-3">
            <div>
              <label class="block text-sm font-semibold mb-1">x0</label>
              <input id="x0Input" type="number" class="input" value="1.5"/>
            </div>
            <div id="x1Col">
              <label class="block text-sm font-semibold mb-1">x1 (Secant)</label>
              <input id="x1Input" type="number" class="input" value="2.5"/>
            </div>
          </div>

          <div class="grid grid-cols-2 gap-3 mt-3">
            <div>
              <label class="block text-sm font-semibold mb-1">Tolerance</label>
              <input id="tolInput" type="number" class="input" value="1e-6"/>
            </div>
            <div>
              <label class="block text-sm font-semibold mb-1">Max iterations</label>
              <input id="kmaxInput" type="number" class="input" value="100"/>
            </div>
          </div>
        </div>

        <div>
          <h2 class="text-lg font-semibold mb-3">Status & Guidance</h2>
          <div id="alertsBox" class="space-y-2 mb-4"></div>
          <div id="summaryBox" class="mb-4"></div>
          <div id="plot" class="w-full h-80 rounded-xl border border-gray-200"></div>
        </div>
      </div>

      <div id="tableBox" class="mt-6">
        <h3 class="text-lg font-semibold mb-2">Iterations</h3>
        <div class="overflow-auto rounded-xl border border-gray-200">
          <table id="iterTable" class="table"></table>
        </div>
        <div id="last3Box" class="mt-3"></div>
      </div>
    </section>

    <!-- LINEAR PANEL -->
    <section id="linearPanel" class="card mb-6 hidden">
      <div class="grid-2">
        <div>
          <h2 class="text-lg font-semibold mb-3">Inputs ‚Äî Gaussian Elimination</h2>

          <!-- Matrix input mode switch -->
          <div class="flex gap-2 mb-3">
            <button id="modePaste" class="btn btn-primary" aria-pressed="true">Paste Matrix</button>
            <button id="modeBuild" class="btn btn-soft" aria-pressed="false">Build Matrix</button>
          </div>

          <!-- PASTE MODE -->
          <div id="pastePanel">
            <label class="block text-sm font-semibold mb-1">Matrix A (rows by newline; values by space or comma)</label>
            <textarea id="AInput" class="input" rows="6">2 -1 0 3
1 0.5 3 8
0 13 -2 11
14 5 -2 3</textarea>

            <label class="block text-sm font-semibold mt-3 mb-1">Vector b</label>
            <input id="bVecInput" class="input" value="1 1 1 1" />
          </div>

          <!-- BUILD MODE -->
          <div id="buildPanel" class="hidden">
            <div class="grid grid-cols-3 gap-3 mb-3">
              <div>
                <label class="block text-sm font-semibold mb-1">Size n</label>
                <input id="nSizeInput" type="number" class="input" value="3" min="1" max="8"/>
              </div>
              <div class="flex items-end">
                <button id="buildBtn" class="btn btn-soft w-full">Build matrix</button>
              </div>
              <div class="flex items-end">
                <button id="clearGridBtn" class="btn btn-soft w-full">Clear</button>
              </div>
            </div>

            <div class="grid lg:grid-cols-[1fr,auto] gap-6">
              <div>
                <div id="AGrid" class="matrix-grid"></div>
              </div>
              <div>
                <div id="bGrid" class="matrix-grid"></div>
              </div>
            </div>

            <p class="hint mt-2">Type numbers into the grid. You can still switch back to ‚ÄúPaste Matrix‚Äù anytime.</p>
          </div>

          <div class="grid grid-cols-2 gap-3 mt-4">
            <div>
              <label class="block text-sm font-semibold mb-1">Tolerance (pivot check)</label>
              <input id="ltolInput" type="number" class="input" value="1e-12"/>
            </div>
            <div>
              <label class="block text-sm font-semibold mb-1">Pivoting</label>
              <select id="pivotSelect" class="select">
                <option value="gaussNone">No Pivoting</option>
                <option value="gaussPartial">Partial Pivoting</option>
                <option value="gaussTotal">Total Pivoting</option>
              </select>
            </div>
          </div>
        </div>

        <div>
          <h2 class="text-lg font-semibold mb-3">Status & Guidance</h2>
          <div id="lAlertsBox" class="space-y-2 mb-4"></div>
          <div id="lSummaryBox" class="mb-2"></div>
          <div id="permBox" class="hint"></div>
        </div>
      </div>

      <div id="lTableBox" class="mt-6">
        <h3 class="text-lg font-semibold mb-2">Solution</h3>
        <div class="overflow-auto rounded-xl border border-gray-200">
          <table id="lTable" class="table"></table>
        </div>
      </div>
    </section>

    <footer class="text-sm text-gray-500 mt-8">
      Tip: expressions like <span class="code">x^2 + 3*x</span> are auto-converted to <span class="code">x**2 + 3*x</span>. Libraries used: Tailwind & Plotly.
    </footer>
  </div>

  <script>
    /* ================= UI Grab ================= */
    const tabRoot = document.getElementById('tabRoot');
    const tabLinear = document.getElementById('tabLinear');
    const methodSelect = document.getElementById('methodSelect');
    const runBtn = document.getElementById('runBtn');
    const resetBtn = document.getElementById('resetBtn');

    /* Root refs */
    const rootPanel = document.getElementById('rootPanel');
    const fxInput = document.getElementById('fxInput');
    const gxGroup = document.getElementById('gxGroup');
    const gxInput = document.getElementById('gxInput');
    const aInput = document.getElementById('aInput');
    const bInput = document.getElementById('bInput');
    const deltaGroup = document.getElementById('deltaGroup');
    const deltaInput = document.getElementById('deltaInput');
    const nmaxInput = document.getElementById('nmaxInput');
    const x0Input = document.getElementById('x0Input');
    const x1Input = document.getElementById('x1Input');
    const x1Col = document.getElementById('x1Col');
    const tolInput = document.getElementById('tolInput');
    const kmaxInput = document.getElementById('kmaxInput');
    const alertsBox = document.getElementById('alertsBox');
    const summaryBox = document.getElementById('summaryBox');
    const plotDiv = document.getElementById('plot');
    const iterTable = document.getElementById('iterTable');
    const last3Box = document.getElementById('last3Box');

    /* Linear refs */
    const linearPanel = document.getElementById('linearPanel');
    const AInput = document.getElementById('AInput');
    const bVecInput = document.getElementById('bVecInput');
    const ltolInput = document.getElementById('ltolInput');
    const pivotSelect = document.getElementById('pivotSelect');
    const lAlertsBox = document.getElementById('lAlertsBox');
    const lSummaryBox = document.getElementById('lSummaryBox');
    const lTable = document.getElementById('lTable');
    const permBox = document.getElementById('permBox');

    /* Matrix builder refs */
    const modePaste = document.getElementById('modePaste');
    const modeBuild = document.getElementById('modeBuild');
    const pastePanel = document.getElementById('pastePanel');
    const buildPanel = document.getElementById('buildPanel');
    const nSizeInput = document.getElementById('nSizeInput');
    const buildBtn = document.getElementById('buildBtn');
    const clearGridBtn = document.getElementById('clearGridBtn');
    const AGrid = document.getElementById('AGrid');
    const bGrid = document.getElementById('bGrid');

    let appMode = 'root';
    function setMode(m){
      appMode = m;
      if (m==='root'){
        rootPanel.classList.remove('hidden');
        linearPanel.classList.add('hidden');
        tabRoot.classList.add('btn-primary'); tabRoot.classList.remove('btn-soft');
        tabLinear.classList.add('btn-soft'); tabLinear.classList.remove('btn-primary');
        if (methodSelect.value.startsWith('gauss')) methodSelect.value='bisection';
      } else {
        linearPanel.classList.remove('hidden');
        rootPanel.classList.add('hidden');
        tabLinear.classList.add('btn-primary'); tabLinear.classList.remove('btn-soft');
        tabRoot.classList.add('btn-soft'); tabRoot.classList.remove('btn-primary');
        if (!methodSelect.value.startsWith('gauss')) methodSelect.value = pivotSelect.value;
      }
      syncVisibility();
      clearRootOutputs(); clearLinearOutputs();
    }
    tabRoot.addEventListener('click',()=>setMode('root'));
    tabLinear.addEventListener('click',()=>setMode('linear'));

    function syncVisibility(){
      const m = methodSelect.value;
      const showDelta = (m==='incremental');
      const showGx    = (m==='fixedPoint');
      const showX1    = (m==='secant');
      deltaGroup.classList.toggle('hidden', !showDelta);
      gxGroup.classList.toggle('hidden', !showGx);
      x1Col.classList.toggle('hidden', !showX1);
      if (appMode==='linear') pivotSelect.value = m;
    }
    methodSelect.addEventListener('change', ()=>{ syncVisibility(); clearRootOutputs(); clearLinearOutputs(); });
    pivotSelect.addEventListener('change', ()=>{ methodSelect.value=pivotSelect.value; syncVisibility(); });

    /* Alerts helpers */
    const alertMsg = (t,kind='warn')=>{
      const c = kind==='ok'?'ok': kind==='error'?'err':'warn';
      return `<div class="rounded-xl border px-3 py-2 ${c}">${t}</div>`; };
    const setHTML=(el,html)=>el.innerHTML=html;
    const appendHTML=(el,html)=>el.insertAdjacentHTML('beforeend',html);

    function clearRootOutputs(){ setHTML(alertsBox,''); setHTML(summaryBox,''); setHTML(iterTable,''); setHTML(last3Box,''); Plotly.purge(plotDiv); }
    function clearLinearOutputs(){ setHTML(lAlertsBox,''); setHTML(lSummaryBox,''); setHTML(lTable,''); setHTML(permBox,''); }

    /* Reset */
    resetBtn.addEventListener('click', ()=>{
      if (appMode==='root'){
        fxInput.value="x**3 - 7*x + 6"; gxInput.value="(x + (7*x - 6)/3)/2";
        aInput.value="0.5"; bInput.value="3.0"; x0Input.value="1.5"; x1Input.value="2.5";
        tolInput.value="1e-6"; kmaxInput.value="100"; deltaInput.value="0.5"; nmaxInput.value="100";
        clearRootOutputs();
      } else {
        AInput.value="2 -1 0 3\n1 0.5 3 8\n0 13 -2 11\n14 5 -2 3";
        bVecInput.value="1 1 1 1"; ltolInput.value="1e-12"; pivotSelect.value="gaussNone"; methodSelect.value="gaussNone";
        clearGrid(); clearLinearOutputs();
      }
    });

    /* ================= Math utils ================= */
    function normalizeExpr(s){ return String(s).replace(/\^/g,'**').replace(/‚àö/g,'sqrt'); }
    function buildFn(expr){ const src=normalizeExpr(expr); return new Function('x',`with(Math){return (${src});}`); }
    function d1(phi,x,h=1e-6){ return (phi(x+h)-phi(x-h))/(2*h); }
    function d2(phi,x,h=1e-5){ return (phi(x+h)-2*phi(x)+phi(x-h))/(h*h); }
    function maxAbsDeriv(phi,a,b,n=60){ let m=0; for(let i=0;i<=n;i++){ const x=a+(b-a)*i/n; m=Math.max(m,Math.abs(d1(phi,x))); } return m; }
    function linspace(a,b,n){ const xs=[]; for(let i=0;i<n;i++) xs.push(a+(b-a)*i/(n-1)); return xs; }
    function round(v,d=10){ const f=Number(v); if(!isFinite(f)) return String(v); return Math.abs(f)>=1e-2&&Math.abs(f)<1e6? f.toFixed(d): f.toExponential(3); }

    /* ================= Plot ================= */
    function plotFx(phi,a,b,iterXs=[],label='iter'){
      const xs=linspace(a,b,300), ys=xs.map(x=>{ const y=phi(x); return Number.isFinite(y)?y:NaN; });
      const trace={x:xs,y:ys,type:'scatter',mode:'lines',name:'f(x)'};
      const it=iterXs.length?{x:iterXs,y:iterXs.map(phi),mode:'markers+lines',type:'scatter',name:label,marker:{size:8},line:{dash:'dot'}}:null;
      Plotly.newPlot('plot', it?[trace,it]:[trace], {margin:{l:36,r:12,t:10,b:36},xaxis:{title:'x'},yaxis:{title:'y'}},{displayModeBar:false,responsive:true});
    }

    /* ================= Tables ================= */
    function renderTable(headers, rows, target){
      const thead='<thead><tr>'+headers.map(h=>`<th>${h}</th>`).join('')+'</tr></thead>';
      const tbody='<tbody>'+rows.map(r=>'<tr>'+r.map(c=>`<td>${c}</td>`).join('')+'</tr>').join('')+'</tbody>';
      target.innerHTML=thead+tbody;
    }
    function renderLast3(rows, mount){
      if(!rows.length) return setHTML(mount,'');
      const last=rows.slice(-3).map(r=>'['+r.join(', ')+']').join('<br/>');
      setHTML(mount, `<div class="hint"><span class="badge ok">Last 3 rows</span><div class="mt-1 code">${last}</div></div>`);
    }

    /* ================= Root methods (same core as before) ================= */
    function incrementalSearch(phi,x0,delta,nmax){
      if(delta===0) return { bracket:null, msg:"Delta must be non-zero." };
      let x1=x0+delta; if(phi(x0)===0) return { bracket:[x0,x0], msg:"Exact root at start." };
      for(let k=0;k<Number(nmax);k++){ const y0=phi(x0), y1=phi(x1); if(y0*y1<0) return { bracket:[x0,x1], msg:`Sign change in [${x0}, ${x1}]` }; x0=x1; x1=x1+delta; }
      return { bracket:null, msg:"No sign change found. Try a different start, range, or delta." };
    }
    function bisection(phi,a,b,tol,kmax){
      const rows=[]; let fa=phi(a), fb=phi(b);
      if(fa===0) return { rows:[[0,a,b,a,phi(a),0,(b-a)/2]], root:a, err:0, k:0 };
      if(fb===0) return { rows:[[0,a,b,b,phi(b),0,(b-a)/2]], root:b, err:0, k:0 };
      if(fa*fb>0) return { error:"No sign change on [a,b]. Please bracket the root first." };
      let xmOld=a, xm=a, fm=phi(a);
      for(let k=1;k<=kmax;k++){ xm=(a+b)/2; fm=phi(xm); const errX=Math.abs(xm-xmOld), errB=(b-a)/2;
        rows.push([k, round(a), round(b), round(xm), round(fm,6), round(errX,6), round(errB,6)]);
        if(fm===0 || errB<=tol || errX<=tol) return { rows, root:xm, err:errX, k };
        if(fa*fm<0){ b=xm; fb=fm; } else { a=xm; fa=fm; } xmOld=xm;
      }
      return { rows, root:xm, err:(b-a)/2, k:kmax };
    }
    function falsePosition(phi,a,b,tol,kmax){
      const rows=[]; let fa=phi(a), fb=phi(b);
      if(fa*fb>0) return { error:"No sign change on [a,b]. Please bracket the root first." };
      let xmOld=a, xm=a;
      for(let k=1;k<=kmax;k++){ fa=phi(a); fb=phi(b); const denom=fb-fa; if(denom===0) return { error:"Zero denominator; try a different interval." };
        xm=b - fb*(b-a)/denom; const fm=phi(xm), err=Math.abs(xm-xmOld);
        rows.push([k, round(a), round(b), round(xm), round(fm,6), round(err,6)]);
        if(fm===0 || err<=tol) return { rows, root:xm, err, k };
        if(fa*fm<0){ b=xm; } else { a=xm; } xmOld=xm;
      }
      return { rows, root:xm, err:Math.abs(xm-xmOld), k:kmax };
    }
    function fixedPoint(psi,a,b,x0,tol,kmax){
      const rows=[]; const kEst=maxAbsDeriv(psi,a,b);
      let warn = (kEst>=1)? `Estimated max |g'| ‚âà ${kEst.toFixed(3)} ‚â• 1 on [${a},${b}] ‚Äî try another g(x) or a tighter interval.`: null;
      for(let k=1;k<=kmax;k++){ const x1=psi(x0), err=Math.abs(x1-x0); rows.push([k,round(x0),round(x1),round(err,6)]); if(err<=tol) return { rows, root:x1, err, k, warn }; x0=x1; }
      return { rows, root:x0, err:rows.at(-1)?.[3], k:kmax, warn };
    }
    function newton(phi,x0,tol,kmax){
      const rows=[]; for(let k=1;k<=kmax;k++){ const fp=d1(phi,x0); if(Math.abs(fp)<1e-12) return { rows, error:"Derivative ~ 0; try a different x0 or bracket first." };
        const x1=x0 - phi(x0)/fp, err=Math.abs(x1-x0); rows.push([k,round(x0),round(phi(x0),6),round(fp,6),round(x1),round(err,6)]);
        if(err<=tol) return { rows, root:x1, err, k }; x0=x1; }
      return { rows, root:x0, err:rows.at(-1)?.[5], k:kmax };
    }
    function secant(phi,x0,x1,tol,kmax){
      const rows=[]; for(let k=1;k<=kmax;k++){ const f0=phi(x0), f1=phi(x1), denom=f1-f0; if(Math.abs(denom)<1e-14) return { rows, error:"Denominator ~ 0; restart with different seeds or bracket first." };
        const x2=x1 - f1*(x1-x0)/denom, err=Math.abs(x2-x1); rows.push([k,round(x0),round(x1),round(x2),round(phi(x2),6),round(err,6)]);
        if(err<=tol) return { rows, root:x2, err, k }; x0=x1; x1=x2; }
      return { rows, root:x1, err:rows.at(-1)?.[5], k:kmax };
    }
    function modifiedNewton(phi,x0,tol,kmax){
      const rows=[]; for(let k=1;k<=kmax;k++){ const fx=phi(x0), fp=d1(phi,x0), fpp=d2(phi,x0), denom=fp*fp - fx*fpp;
        if(Math.abs(denom)<1e-14) return { rows, error:"Unstable step: denominator ~ 0. Try a different x0 or bracket first." };
        const x1=x0 - fx*fp/denom, err=Math.abs(x1-x0); rows.push([k,round(x0),round(fx,6),round(fp,6),round(fpp,6),round(x1),round(err,6)]);
        if(err<=tol) return { rows, root:x1, err, k }; x0=x1; }
      return { rows, root:x0, err:rows.at(-1)?.[6], k:kmax };
    }

    /* ================= Linear systems ================= */
    function parseMatrix(text){
      const rows=String(text).trim().split(/\n+/).map(line=> line.trim().split(/[,\s]+/).filter(Boolean).map(Number));
      const n=rows.length; if(!rows.every(r=>r.length===n)) throw new Error("A must be square (n x n)."); return rows;
    }
    function parseVector(text){ return String(text).trim().split(/[,\s]+/).filter(Boolean).map(Number); }
    function backSubstitution(U,b,tol=1e-12){
      const n=U.length, x=Array(n).fill(0);
      if(Math.abs(U[n-1][n-1])<=tol) throw new Error("Back substitution failed: near-zero pivot at last row.");
      x[n-1]=b[n-1]/U[n-1][n-1];
      for(let i=n-2;i>=0;i--){ let s=0; for(let j=i+1;j<n;j++) s+=U[i][j]*x[j]; if(Math.abs(U[i][i])<=tol) throw new Error(`Back substitution failed at row ${i}: near-zero pivot.`);
        x[i]=(b[i]-s)/U[i][i]; }
      return x;
    }
    function gaussNoPivot(Ain, bin, tol=1e-12){
      const A=Ain.map(r=>r.slice()), b=bin.slice(), n=A.length;
      for(let k=0;k<n-1;k++){ if(Math.abs(A[k][k])<=tol) throw new Error("Zero/near-zero pivot. Try Partial/Total Pivoting or rescale.");
        for(let i=k+1;i<n;i++){ const m=A[i][k]/A[k][k]; for(let j=k;j<n;j++) A[i][j]-=m*A[k][j]; b[i]-=m*b[k]; } }
      return { x: backSubstitution(A,b,tol) };
    }
    function gaussPartial(Ain,bin,tol=1e-12){
      const A=Ain.map(r=>r.slice()), b=bin.slice(), n=A.length;
      for(let k=0;k<n-1;k++){ let p=k, maxv=Math.abs(A[k][k]); for(let i=k+1;i<n;i++){ const v=Math.abs(A[i][k]); if(v>maxv){maxv=v;p=i;} }
        if(maxv<=tol) throw new Error("All candidate pivots ~ 0. Singular/ill-conditioned.");
        if(p!==k){ const tr=A[k]; A[k]=A[p]; A[p]=tr; const tb=b[k]; b[k]=b[p]; b[p]=tb; }
        for(let i=k+1;i<n;i++){ const m=A[i][k]/A[k][k]; for(let j=k;j<n;j++) A[i][j]-=m*A[k][j]; b[i]-=m*b[k]; } }
      return { x: backSubstitution(A,b,tol) };
    }
    function gaussTotal(Ain,bin,tol=1e-12){
      const A=Ain.map(r=>r.slice()), b=bin.slice(), n=A.length, colPerm=Array.from({length:n},(_,i)=>i);
      for(let k=0;k<n-1;k++){ let p=k,q=k,maxv=Math.abs(A[k][k]); for(let i=k;i<n;i++) for(let j=k;j<n;j++){ const v=Math.abs(A[i][j]); if(v>maxv){ maxv=v; p=i; q=j; } }
        if(maxv<=tol) throw new Error("Active submatrix ~ 0. Singular/ill-conditioned.");
        if(p!==k){ const tr=A[k]; A[k]=A[p]; A[p]=tr; const tb=b[k]; b[k]=b[p]; b[p]=tb; }
        if(q!==k){ for(let i=0;i<n;i++){ const t=A[i][k]; A[i][k]=A[i][q]; A[i][q]=t; } const tp=colPerm[k]; colPerm[k]=colPerm[q]; colPerm[q]=tp; }
        for(let i=k+1;i<n;i++){ const m=A[i][k]/A[k][k]; for(let j=k;j<n;j++) A[i][j]-=m*A[k][j]; b[i]-=m*b[k]; } }
      const y=backSubstitution(A,b,tol), x=Array(n).fill(0); for(let j=0;j<n;j++) x[colPerm[j]]=y[j];
      return { x, colPerm };
    }

    /* ============== Matrix Builder ============== */
    let buildMode = 'paste';
    function setBuildMode(m){
      buildMode=m;
      if (m==='paste'){ pastePanel.classList.remove('hidden'); buildPanel.classList.add('hidden'); modePaste.classList.add('btn-primary'); modePaste.classList.remove('btn-soft'); modeBuild.classList.add('btn-soft'); modeBuild.classList.remove('btn-primary'); }
      else { buildPanel.classList.remove('hidden'); pastePanel.classList.add('hidden'); modeBuild.classList.add('btn-primary'); modeBuild.classList.remove('btn-soft'); modePaste.classList.add('btn-soft'); modePaste.classList.remove('btn-primary'); }
    }
    modePaste.addEventListener('click', ()=>setBuildMode('paste'));
    modeBuild.addEventListener('click', ()=>setBuildMode('build'));

    function clearGrid(){ AGrid.innerHTML=''; bGrid.innerHTML=''; }
    function buildGrid(){
      clearGrid();
      const n = Math.max(1, Math.min(8, Number(nSizeInput.value)||3));
      const AFrag = document.createDocumentFragment();
      const table = document.createElement('table'); table.className='table';
      const thead = document.createElement('thead'); const trh=document.createElement('tr');
      for (let j=0;j<n;j++){ const th=document.createElement('th'); th.textContent='A[:, '+(j+1)+']'; trh.appendChild(th); } thead.appendChild(trh); table.appendChild(thead);
      const tbody=document.createElement('tbody');
      for (let i=0;i<n;i++){
        const tr=document.createElement('tr');
        for (let j=0;j<n;j++){
          const td=document.createElement('td'); const inp=document.createElement('input'); inp.className='input'; inp.placeholder='0'; inp.setAttribute('data-i',i); inp.setAttribute('data-j',j);
          td.appendChild(inp); tr.appendChild(td);
        }
        tbody.appendChild(tr);
      }
      table.appendChild(tbody); AFrag.appendChild(table); AGrid.appendChild(AFrag);

      const bT=document.createElement('table'); bT.className='table';
      const bh=document.createElement('thead'); const br=document.createElement('tr'); const thb=document.createElement('th'); thb.textContent='b'; br.appendChild(thb); bh.appendChild(br); bT.appendChild(bh);
      const bb=document.createElement('tbody');
      for (let i=0;i<n;i++){ const tr=document.createElement('tr'); const td=document.createElement('td'); const inp=document.createElement('input'); inp.className='input'; inp.placeholder='0'; inp.setAttribute('data-i',i); td.appendChild(inp); tr.appendChild(td); bb.appendChild(tr); }
      bT.appendChild(bb); bGrid.appendChild(bT);
    }
    buildBtn.addEventListener('click', buildGrid);
    clearGridBtn.addEventListener('click', clearGrid);

    function collectGrid(){
      const n = bGrid.querySelectorAll('tbody tr').length;
      if (!n){ throw new Error('Build the matrix grid first.'); }
      const A=[], b=[];
      for (let i=0;i<n;i++){
        const row=[];
        const cells = AGrid.querySelectorAll(`tbody tr:nth-child(${i+1}) td input`);
        cells.forEach(inp=> row.push(Number(inp.value||'0')) );
        A.push(row);
        const binp = bGrid.querySelector(`tbody tr:nth-child(${i+1}) td input`);
        b.push(Number(binp.value||'0'));
      }
      return { A, b };
    }

    /* ============== Runners ============== */
    runBtn.addEventListener('click', ()=>{ if(appMode==='root') runRoot(); else runLinear(); });

    function runRoot(){
      clearRootOutputs();
      let f, g=null; try{ f=buildFn(fxInput.value); }catch(e){ setHTML(alertsBox, alertMsg("Invalid f(x). Please check your expression.", 'error')); return; }
      const m = methodSelect.value;
      if (m==='fixedPoint'){ try{ g=buildFn(gxInput.value);}catch(e){ setHTML(alertsBox, alertMsg("Invalid g(x). Please check your expression.", 'error')); return; } }
      const a=Number(aInput.value), b=Number(bInput.value), x0=Number(x0Input.value), x1=Number(x1Input.value);
      const tol=Number(tolInput.value), kmax=Number(kmaxInput.value), delta=Number(deltaInput.value), nmax=Number(nmaxInput.value);
      if(!isFinite(a)||!isFinite(b)||a===b) return setHTML(alertsBox, alertMsg("Interval [a,b] looks off. Try different endpoints.", 'error'));
      if(!(tol>0)) return setHTML(alertsBox, alertMsg("Tolerance must be positive.", 'error'));
      if(!(kmax>0)) return setHTML(alertsBox, alertMsg("Max iterations must be positive.", 'error'));

      plotFx(f,a,b,[], 'iter');

      try{
        let headers=[], rows=[], itXs=[];
        if (m==='incremental'){
          const r=incrementalSearch(f,x0,delta,nmax);
          if(!r.bracket){ appendHTML(alertsBox, alertMsg(r.msg,'warn')); appendHTML(alertsBox, alertMsg("Try expanding the range, changing Œî, or plotting to spot sign changes.", 'ok')); return; }
          setHTML(summaryBox, `<span class="badge ok">Bracket</span> Use [${round(r.bracket[0])}, ${round(r.bracket[1])}] as your starting interval for Bisection/False Position.`);
          plotFx(f,a,b,[r.bracket[0], r.bracket[1]], 'bracket');
          headers=["Note","a","b"]; rows=[["Found", round(r.bracket[0]), round(r.bracket[1])]];
        }
        else if (m==='bisection'){
          const r=bisection(f,a,b,tol,kmax);
          if(r.error){ appendHTML(alertsBox, alertMsg(r.error,'warn')); appendHTML(alertsBox, alertMsg("Pro tip: run Incremental Search first to locate a valid bracket.", 'ok')); return;}
          headers=["k","a","b","xm","f(xm)","|dx|","(b-a)/2"]; rows=r.rows;
          setHTML(summaryBox, `<span class="badge ok">Root</span> x* ‚âà <span class="code">${round(r.root)}</span> ¬∑ <span class="badge ok">iterations: ${r.k}</span>`);
          itXs=r.rows.map(v=>Number(v[3])); plotFx(f,a,b,itXs,'xm');
        }
        else if (m==='falsePosition'){
          const r=falsePosition(f,a,b,tol,kmax);
          if(r.error){ appendHTML(alertsBox, alertMsg(r.error,'warn')); appendHTML(alertsBox, alertMsg("Try Incremental Search to find a bracket with f(a)*f(b)<0.", 'ok')); return;}
          headers=["k","a","b","xm","f(xm)","|dx|"]; rows=r.rows;
          setHTML(summaryBox, `<span class="badge ok">Root</span> x* ‚âà <span class="code">${round(r.root)}</span> ¬∑ <span class="badge ok">iterations: ${r.k}</span>`);
          itXs=r.rows.map(v=>Number(v[3])); plotFx(f,a,b,itXs,'xm');
        }
        else if (m==='fixedPoint'){
          const r=fixedPoint(g,a,b,x0,tol,kmax); if(r.warn) appendHTML(alertsBox, alertMsg(r.warn,'warn'));
          headers=["k","x_k","g(x_k)","|dx|"]; rows=r.rows;
          setHTML(summaryBox, `<span class="badge ok">Fixed Point</span> x* ‚âà <span class="code">${round(r.root)}</span> ¬∑ <span class="badge ok">iterations: ${r.k}</span>`);
          itXs=r.rows.map(v=>Number(v[2])); plotFx(f,a,b,itXs,'x_k');
          appendHTML(alertsBox, alertMsg("If it diverges, try a different g(x) or a tighter interval where |g'|<1.", 'ok'));
        }
        else if (m==='newton'){
          const r=newton(f,x0,tol,kmax); if(r.error){ appendHTML(alertsBox, alertMsg(r.error,'warn')); appendHTML(alertsBox, alertMsg("Pick a different x0 or bracket first, then switch back.", 'ok')); return;}
          headers=["k","x_k","f(x_k)","f'(x_k)","x_{k+1}","|dx|"]; rows=r.rows;
          setHTML(summaryBox, `<span class="badge ok">Root</span> x* ‚âà <span class="code">${round(r.root)}</span> ¬∑ <span class="badge ok">iterations: ${r.k}</span>`);
          itXs=r.rows.map(v=>Number(v[4])); plotFx(f,a,b,itXs,'x_k');
        }
        else if (m==='secant'){
          const r=secant(f,x0,x1,tol,kmax); if(r.error){ appendHTML(alertsBox, alertMsg(r.error,'warn')); appendHTML(alertsBox, alertMsg("Restart with different seeds or bracket first.", 'ok')); return;}
          headers=["k","x_{k-1}","x_k","x_{k+1}","f(x_{k+1})","|dx|"]; rows=r.rows;
          setHTML(summaryBox, `<span class="badge ok">Root</span> x* ‚âà <span class="code">${round(r.root)}</span> ¬∑ <span class="badge ok">iterations: ${r.k}</span>`);
          itXs=r.rows.map(v=>Number(v[3])); plotFx(f,a,b,itXs,'x_k');
        }
        else if (m==='multiple'){
          const r=modifiedNewton(f,x0,tol,kmax); if(r.error){ appendHTML(alertsBox, alertMsg(r.error,'warn')); appendHTML(alertsBox, alertMsg("Try another x0 or approach the root with bracketing.", 'ok')); return;}
          headers=["k","x_k","f(x)","f'(x)","f''(x)","x_{k+1}","|dx|"]; rows=r.rows;
          setHTML(summaryBox, `<span class="badge ok">Root</span> x* ‚âà <span class="code">${round(r.root)}</span> ¬∑ <span class="badge ok">iterations: ${r.k}</span>`);
          itXs=r.rows.map(v=>Number(v[5])); plotFx(f,a,b,itXs,'x_k');
        }

        if(headers.length){ renderTable(headers, rows, iterTable); renderLast3(rows, last3Box); }
      }catch(e){ appendHTML(alertsBox, alertMsg("Computation failed: "+e.message,'error')); }
    }

    function runLinear(){
      clearLinearOutputs();
      const m = methodSelect.value; // gaussNone / gaussPartial / gaussTotal

      // Collect matrix either from paste or from grid
      let A, b, tol;
      try{
        tol = Number(ltolInput.value); if(!(tol>0)) throw new Error("Tolerance must be positive.");
        if (buildMode==='paste'){
          A = parseMatrix(AInput.value); b = parseVector(bVecInput.value); if (b.length!==A.length) throw new Error("Vector b must have length n.");
        } else {
          const g = collectGrid(); A=g.A; b=g.b;
        }
      }catch(e){ return setHTML(lAlertsBox, alertMsg(e.message,'error')); }

      try{
        let r=null;
        if (m==='gaussNone') r=gaussNoPivot(A,b,tol);
        else if (m==='gaussPartial') r=gaussPartial(A,b,tol);
        else r=gaussTotal(A,b,tol);

        const headers=["i","x_i"], rows=r.x.map((xi,i)=>[i+1, round(xi,10)]);
        renderTable(headers, rows, lTable);

        let sum = `<span class="badge ok">Solved</span> with ${m==='gaussNone'?'no pivoting':m==='gaussPartial'?'partial pivoting':'total pivoting'}.`;
        if (m==='gaussNone') appendHTML(lAlertsBox, alertMsg("Heads-up: without pivoting, small pivots can break stability. Prefer partial/total pivoting when in doubt.", 'warn'));
        setHTML(lSummaryBox, sum);

        if (r.colPerm){ setHTML(permBox, `<span class="badge ok">Column permutation</span> <span class="code">[${r.colPerm.join(', ')}]</span> ‚Äî solution is reported in the original variable order.`); }
        else setHTML(permBox, '');
      } catch(e){
        setHTML(lAlertsBox, alertMsg("Computation failed: "+e.message,'error'));
        if (/pivot/i.test(e.message)) appendHTML(lAlertsBox, alertMsg("Try Partial or Total Pivoting; also consider rescaling rows/columns.", 'ok'));
      }
    }

    /* Matrix mode switch */
    function initMatrixMode(){
      setBuildMode('paste');
      buildBtn.addEventListener('click', buildGrid);
      clearGridBtn.addEventListener('click', clearGrid);
    }

    /* Init */
    setMode('root');
    syncVisibility();
    initMatrixMode();
    // starter plot
    try{ plotFx(buildFn(fxInput.value), Number(aInput.value), Number(bInput.value), [], 'iter'); }catch{}
  </script>
</body>
</html>
